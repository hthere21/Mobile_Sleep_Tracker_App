{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nvar fs = require('fs'),\n    path = require('path'),\n    rimraf = require('rimraf'),\n    tmp = require('tmp');\n/**\n * @param {!Function} fn .\n * @return {!Promise<T>} .\n * @template T\n */\n\n\nfunction checkedCall(fn) {\n  return new Promise((resolve, reject) => {\n    try {\n      fn((err, value) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n} // PUBLIC API\n\n/**\n * Recursively removes a directory and all of its contents. This is equivalent\n * to {@code rm -rf} on a POSIX system.\n * @param {string} dirPath Path to the directory to remove.\n * @return {!Promise} A promise to be resolved when the operation has\n *     completed.\n */\n\n\nexports.rmDir = function (dirPath) {\n  return new Promise(function (fulfill, reject) {\n    var numAttempts = 0;\n    attemptRm();\n\n    function attemptRm() {\n      numAttempts += 1;\n      rimraf(dirPath, function (err) {\n        if (err) {\n          if (err.code && err.code === 'ENOTEMPTY' && numAttempts < 2) {\n            attemptRm();\n            return;\n          }\n\n          reject(err);\n        } else {\n          fulfill();\n        }\n      });\n    }\n  });\n};\n/**\n * Copies one file to another.\n * @param {string} src The source file.\n * @param {string} dst The destination file.\n * @return {!Promise<string>} A promise for the copied file's path.\n */\n\n\nexports.copy = function (src, dst) {\n  return new Promise(function (fulfill, reject) {\n    var rs = fs.createReadStream(src);\n    rs.on('error', reject);\n    rs.on('end', () => fulfill(dst));\n    var ws = fs.createWriteStream(dst);\n    ws.on('error', reject);\n    rs.pipe(ws);\n  });\n};\n/**\n * Recursively copies the contents of one directory to another.\n * @param {string} src The source directory to copy.\n * @param {string} dst The directory to copy into.\n * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter\n *     as either a regex or predicate function. All files matching this filter\n *     will not be copied.\n * @return {!Promise<string>} A promise for the destination\n *     directory's path once all files have been copied.\n */\n\n\nexports.copyDir = function (src, dst, opt_exclude) {\n  var predicate = opt_exclude;\n\n  if (opt_exclude && typeof opt_exclude !== 'function') {\n    predicate = function (p) {\n      return !opt_exclude.test(p);\n    };\n  } // TODO(jleyba): Make this function completely async.\n\n\n  if (!fs.existsSync(dst)) {\n    fs.mkdirSync(dst);\n  }\n\n  var files = fs.readdirSync(src);\n  files = files.map(function (file) {\n    return path.join(src, file);\n  });\n\n  if (predicate) {\n    files = files.filter(\n    /** @type {function(string): boolean} */\n    predicate);\n  }\n\n  var results = [];\n  files.forEach(function (file) {\n    var stats = fs.statSync(file);\n    var target = path.join(dst, path.basename(file));\n\n    if (stats.isDirectory()) {\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, stats.mode);\n      }\n\n      results.push(exports.copyDir(file, target, predicate));\n    } else {\n      results.push(exports.copy(file, target));\n    }\n  });\n  return Promise.all(results).then(() => dst);\n};\n/**\n * Tests if a file path exists.\n * @param {string} aPath The path to test.\n * @return {!Promise<boolean>} A promise for whether the file exists.\n */\n\n\nexports.exists = function (aPath) {\n  return new Promise(function (fulfill, reject) {\n    let type = typeof aPath;\n\n    if (type !== 'string') {\n      reject(TypeError(`expected string path, but got ${type}`));\n    } else {\n      fs.exists(aPath, fulfill);\n    }\n  });\n};\n/**\n * Calls `stat(2)`.\n * @param {string} aPath The path to stat.\n * @return {!Promise<!fs.Stats>} A promise for the file stats.\n */\n\n\nexports.stat = function stat(aPath) {\n  return checkedCall(callback => fs.stat(aPath, callback));\n};\n/**\n * Deletes a name from the filesystem and possibly the file it refers to. Has\n * no effect if the file does not exist.\n * @param {string} aPath The path to remove.\n * @return {!Promise} A promise for when the file has been removed.\n */\n\n\nexports.unlink = function (aPath) {\n  return new Promise(function (fulfill, reject) {\n    fs.exists(aPath, function (exists) {\n      if (exists) {\n        fs.unlink(aPath, function (err) {\n          err && reject(err) || fulfill();\n        });\n      } else {\n        fulfill();\n      }\n    });\n  });\n};\n/**\n * @return {!Promise<string>} A promise for the path to a temporary directory.\n * @see https://www.npmjs.org/package/tmp\n */\n\n\nexports.tmpDir = function () {\n  return checkedCall(tmp.dir);\n};\n/**\n * @param {{postfix: string}=} opt_options Temporary file options.\n * @return {!Promise<string>} A promise for the path to a temporary file.\n * @see https://www.npmjs.org/package/tmp\n */\n\n\nexports.tmpFile = function (opt_options) {\n  return checkedCall(callback => {\n    // |tmp.file| checks arguments length to detect options rather than doing a\n    // truthy check, so we must only pass options if there are some to pass.\n    if (opt_options) {\n      tmp.file(opt_options, callback);\n    } else {\n      tmp.file(callback);\n    }\n  });\n};\n/**\n * Searches the {@code PATH} environment variable for the given file.\n * @param {string} file The file to locate on the PATH.\n * @param {boolean=} opt_checkCwd Whether to always start with the search with\n *     the current working directory, regardless of whether it is explicitly\n *     listed on the PATH.\n * @return {?string} Path to the located file, or {@code null} if it could\n *     not be found.\n */\n\n\nexports.findInPath = function (file, opt_checkCwd) {\n  let dirs = [];\n\n  if (opt_checkCwd) {\n    dirs.push(process.cwd());\n  }\n\n  dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter));\n  let foundInDir = dirs.find(dir => {\n    let tmp = path.join(dir, file);\n\n    try {\n      let stats = fs.statSync(tmp);\n      return stats.isFile() && !stats.isDirectory();\n    } catch (ex) {\n      return false;\n    }\n  });\n  return foundInDir ? path.join(foundInDir, file) : null;\n};\n/**\n * Reads the contents of the given file.\n *\n * @param {string} aPath Path to the file to read.\n * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the\n *     file contents.\n */\n\n\nexports.read = function (aPath) {\n  return checkedCall(callback => fs.readFile(aPath, callback));\n};\n/**\n * Writes to a file.\n *\n * @param {string} aPath Path to the file to write to.\n * @param {(string|!Buffer)} data The data to write.\n * @return {!Promise} A promise that will resolve when the operation has\n *     completed.\n */\n\n\nexports.write = function (aPath, data) {\n  return checkedCall(callback => fs.writeFile(aPath, data, callback));\n};\n/**\n * Creates a directory.\n *\n * @param {string} aPath The directory path.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\n\n\nexports.mkdir = function (aPath) {\n  return checkedCall(callback => {\n    fs.mkdir(aPath, undefined, err => {\n      if (err && err.code !== 'EEXIST') {\n        callback(err);\n      } else {\n        callback(null, aPath);\n      }\n    });\n  });\n};\n/**\n * Recursively creates a directory and any ancestors that do not yet exist.\n *\n * @param {string} dir The directory path to create.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\n\n\nexports.mkdirp = function mkdirp(dir) {\n  return checkedCall(callback => {\n    fs.mkdir(dir, undefined, err => {\n      if (!err) {\n        callback(null, dir);\n        return;\n      }\n\n      switch (err.code) {\n        case 'EEXIST':\n          callback(null, dir);\n          return;\n\n        case 'ENOENT':\n          return mkdirp(path.dirname(dir)).then(() => mkdirp(dir)).then(() => callback(null, dir), err => callback(err));\n\n        default:\n          callback(err);\n          return;\n      }\n    });\n  });\n};\n/**\n * Recursively walks a directory, returning a promise that will resolve with\n * a list of all files/directories seen.\n *\n * @param {string} rootPath the directory to walk.\n * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will\n *     resolve with a list of entries seen. For each entry, the recorded path\n *     will be relative to `rootPath`.\n */\n\n\nexports.walkDir = function (rootPath) {\n  let seen = [];\n  return function walk(dir) {\n    return checkedCall(callback => fs.readdir(dir, callback)).then(files => Promise.all(files.map(file => {\n      file = path.join(dir, file);\n      return checkedCall(cb => fs.stat(file, cb)).then(stats => {\n        seen.push({\n          path: path.relative(rootPath, file),\n          dir: stats.isDirectory()\n        });\n        return stats.isDirectory() && walk(file);\n      });\n    })));\n  }(rootPath).then(() => seen);\n};","map":{"version":3,"names":["fs","require","path","rimraf","tmp","checkedCall","fn","Promise","resolve","reject","err","value","e","exports","rmDir","dirPath","fulfill","numAttempts","attemptRm","code","copy","src","dst","rs","createReadStream","on","ws","createWriteStream","pipe","copyDir","opt_exclude","predicate","p","test","existsSync","mkdirSync","files","readdirSync","map","file","join","filter","results","forEach","stats","statSync","target","basename","isDirectory","mode","push","all","then","exists","aPath","type","TypeError","stat","callback","unlink","tmpDir","dir","tmpFile","opt_options","findInPath","opt_checkCwd","dirs","process","cwd","apply","env","split","delimiter","foundInDir","find","isFile","ex","read","readFile","write","data","writeFile","mkdir","undefined","mkdirp","dirname","walkDir","rootPath","seen","walk","readdir","cb","relative"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/selenium-webdriver/io/index.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\nvar fs = require('fs'),\n    path = require('path'),\n    rimraf = require('rimraf'),\n    tmp = require('tmp');\n\n\n/**\n * @param {!Function} fn .\n * @return {!Promise<T>} .\n * @template T\n */\nfunction checkedCall(fn) {\n  return new Promise((resolve, reject) => {\n    try {\n      fn((err, value) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n\n\n// PUBLIC API\n\n\n\n/**\n * Recursively removes a directory and all of its contents. This is equivalent\n * to {@code rm -rf} on a POSIX system.\n * @param {string} dirPath Path to the directory to remove.\n * @return {!Promise} A promise to be resolved when the operation has\n *     completed.\n */\nexports.rmDir = function(dirPath) {\n  return new Promise(function(fulfill, reject) {\n    var numAttempts = 0;\n    attemptRm();\n    function attemptRm() {\n      numAttempts += 1;\n      rimraf(dirPath, function(err) {\n        if (err) {\n          if (err.code && err.code === 'ENOTEMPTY' && numAttempts < 2) {\n            attemptRm();\n            return;\n          }\n          reject(err);\n        } else {\n          fulfill();\n        }\n      });\n    }\n  });\n};\n\n\n/**\n * Copies one file to another.\n * @param {string} src The source file.\n * @param {string} dst The destination file.\n * @return {!Promise<string>} A promise for the copied file's path.\n */\nexports.copy = function(src, dst) {\n  return new Promise(function(fulfill, reject) {\n    var rs = fs.createReadStream(src);\n    rs.on('error', reject);\n    rs.on('end', () => fulfill(dst));\n\n    var ws = fs.createWriteStream(dst);\n    ws.on('error', reject);\n\n    rs.pipe(ws);\n  });\n};\n\n\n/**\n * Recursively copies the contents of one directory to another.\n * @param {string} src The source directory to copy.\n * @param {string} dst The directory to copy into.\n * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter\n *     as either a regex or predicate function. All files matching this filter\n *     will not be copied.\n * @return {!Promise<string>} A promise for the destination\n *     directory's path once all files have been copied.\n */\nexports.copyDir = function(src, dst, opt_exclude) {\n  var predicate = opt_exclude;\n  if (opt_exclude && typeof opt_exclude !== 'function') {\n    predicate = function(p) {\n      return !opt_exclude.test(p);\n    };\n  }\n\n  // TODO(jleyba): Make this function completely async.\n  if (!fs.existsSync(dst)) {\n    fs.mkdirSync(dst);\n  }\n\n  var files = fs.readdirSync(src);\n  files = files.map(function(file) {\n    return path.join(src, file);\n  });\n\n  if (predicate) {\n    files = files.filter(/** @type {function(string): boolean} */(predicate));\n  }\n\n  var results = [];\n  files.forEach(function(file) {\n    var stats = fs.statSync(file);\n    var target = path.join(dst, path.basename(file));\n\n    if (stats.isDirectory()) {\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, stats.mode);\n      }\n      results.push(exports.copyDir(file, target, predicate));\n    } else {\n      results.push(exports.copy(file, target));\n    }\n  });\n\n  return Promise.all(results).then(() => dst);\n};\n\n\n/**\n * Tests if a file path exists.\n * @param {string} aPath The path to test.\n * @return {!Promise<boolean>} A promise for whether the file exists.\n */\nexports.exists = function(aPath) {\n  return new Promise(function(fulfill, reject) {\n    let type = typeof aPath;\n    if (type !== 'string') {\n      reject(TypeError(`expected string path, but got ${type}`));\n    } else {\n      fs.exists(aPath, fulfill);\n    }\n  });\n};\n\n\n/**\n * Calls `stat(2)`.\n * @param {string} aPath The path to stat.\n * @return {!Promise<!fs.Stats>} A promise for the file stats.\n */\nexports.stat = function stat(aPath) {\n  return checkedCall(callback => fs.stat(aPath, callback));\n};\n\n\n/**\n * Deletes a name from the filesystem and possibly the file it refers to. Has\n * no effect if the file does not exist.\n * @param {string} aPath The path to remove.\n * @return {!Promise} A promise for when the file has been removed.\n */\nexports.unlink = function(aPath) {\n  return new Promise(function(fulfill, reject) {\n    fs.exists(aPath, function(exists) {\n      if (exists) {\n        fs.unlink(aPath, function(err) {\n          err && reject(err) || fulfill();\n        });\n      } else {\n        fulfill();\n      }\n    });\n  });\n};\n\n\n/**\n * @return {!Promise<string>} A promise for the path to a temporary directory.\n * @see https://www.npmjs.org/package/tmp\n */\nexports.tmpDir = function() {\n  return checkedCall(tmp.dir);\n};\n\n\n/**\n * @param {{postfix: string}=} opt_options Temporary file options.\n * @return {!Promise<string>} A promise for the path to a temporary file.\n * @see https://www.npmjs.org/package/tmp\n */\nexports.tmpFile = function(opt_options) {\n  return checkedCall(callback => {\n    // |tmp.file| checks arguments length to detect options rather than doing a\n    // truthy check, so we must only pass options if there are some to pass.\n    if (opt_options) {\n      tmp.file(opt_options, callback);\n    } else {\n      tmp.file(callback);\n    }\n  });\n};\n\n\n/**\n * Searches the {@code PATH} environment variable for the given file.\n * @param {string} file The file to locate on the PATH.\n * @param {boolean=} opt_checkCwd Whether to always start with the search with\n *     the current working directory, regardless of whether it is explicitly\n *     listed on the PATH.\n * @return {?string} Path to the located file, or {@code null} if it could\n *     not be found.\n */\nexports.findInPath = function(file, opt_checkCwd) {\n  let dirs = [];\n  if (opt_checkCwd) {\n    dirs.push(process.cwd());\n  }\n  dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter));\n\n  let foundInDir = dirs.find(dir => {\n    let tmp = path.join(dir, file);\n    try {\n      let stats = fs.statSync(tmp);\n      return stats.isFile() && !stats.isDirectory();\n    } catch (ex) {\n      return false;\n    }\n  });\n\n  return foundInDir ? path.join(foundInDir, file) : null;\n};\n\n\n/**\n * Reads the contents of the given file.\n *\n * @param {string} aPath Path to the file to read.\n * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the\n *     file contents.\n */\nexports.read = function(aPath) {\n  return checkedCall(callback => fs.readFile(aPath, callback));\n};\n\n\n/**\n * Writes to a file.\n *\n * @param {string} aPath Path to the file to write to.\n * @param {(string|!Buffer)} data The data to write.\n * @return {!Promise} A promise that will resolve when the operation has\n *     completed.\n */\nexports.write = function(aPath, data) {\n  return checkedCall(callback => fs.writeFile(aPath, data, callback));\n};\n\n\n/**\n * Creates a directory.\n *\n * @param {string} aPath The directory path.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nexports.mkdir = function(aPath) {\n  return checkedCall(callback => {\n    fs.mkdir(aPath, undefined, err => {\n      if (err && err.code !== 'EEXIST') {\n        callback(err);\n      } else {\n        callback(null, aPath);\n      }\n    });\n  });\n};\n\n\n/**\n * Recursively creates a directory and any ancestors that do not yet exist.\n *\n * @param {string} dir The directory path to create.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nexports.mkdirp = function mkdirp(dir) {\n  return checkedCall(callback => {\n    fs.mkdir(dir, undefined, err => {\n      if (!err) {\n        callback(null, dir);\n        return;\n      }\n\n      switch (err.code) {\n        case 'EEXIST':\n          callback(null, dir);\n          return;\n        case 'ENOENT':\n          return mkdirp(path.dirname(dir))\n              .then(() => mkdirp(dir))\n              .then(() => callback(null, dir), err => callback(err));\n        default:\n          callback(err);\n          return;\n      }\n    });\n  });\n};\n\n\n/**\n * Recursively walks a directory, returning a promise that will resolve with\n * a list of all files/directories seen.\n *\n * @param {string} rootPath the directory to walk.\n * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will\n *     resolve with a list of entries seen. For each entry, the recorded path\n *     will be relative to `rootPath`.\n */\nexports.walkDir = function(rootPath) {\n  let seen = [];\n  return (function walk(dir) {\n    return checkedCall(callback => fs.readdir(dir, callback))\n        .then(files => Promise.all(files.map(file => {\n          file = path.join(dir, file);\n          return checkedCall(cb => fs.stat(file, cb)).then(stats => {\n            seen.push({\n              path: path.relative(rootPath, file),\n              dir: stats.isDirectory()\n            });\n            return stats.isDirectory() && walk(file);\n          });\n        })));\n  })(rootPath).then(() => seen);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}