{"ast":null,"code":"/**\n * Copied from Protractor 5.2.0\n *\n * Wait until Angular has finished rendering and has\n * no outstanding $http calls before continuing. The specific Angular app\n * is determined by the rootSelector.\n *\n * Asynchronous.\n *\n * @param {string} rootSelector The selector housing an ng-app\n * @param {function(string)} callback callback. If a failure occurs, it will\n *     be passed as a parameter.\n */\nfunction waitForAngular(rootSelector, callback) {\n  try {\n    // Wait for both angular1 testability and angular2 testability.\n    var testCallback = callback; // Wait for angular1 testability first and run waitForAngular2 as a callback\n\n    var waitForAngular1 = function (callback) {\n      if (window.angular) {\n        var hooks = getNg1Hooks(rootSelector);\n\n        if (!hooks) {\n          callback(); // not an angular1 app\n        } else {\n          if (hooks.$$testability) {\n            hooks.$$testability.whenStable(callback);\n          } else if (hooks.$injector) {\n            hooks.$injector.get('$browser').notifyWhenNoOutstandingRequests(callback);\n          } else if (!!rootSelector) {\n            throw new Error('Could not automatically find injector on page: \"' + window.location.toString() + '\".  Consider using config.rootEl');\n          } else {\n            throw new Error('root element (' + rootSelector + ') has no injector.' + ' this may mean it is not inside ng-app.');\n          }\n        }\n      } else {\n        callback();\n      } // not an angular1 app\n\n    }; // Wait for Angular2 testability and then run test callback\n\n\n    var waitForAngular2 = function () {\n      if (window.getAngularTestability) {\n        if (rootSelector) {\n          var testability = null;\n          var el = document.querySelector(rootSelector);\n\n          try {\n            testability = window.getAngularTestability(el);\n          } catch (e) {}\n\n          if (testability) {\n            return testability.whenStable(testCallback);\n          }\n        } // Didn't specify root element or testability could not be found\n        // by rootSelector. This may happen in a hybrid app, which could have\n        // more than one root.\n\n\n        var testabilities = window.getAllAngularTestabilities();\n        var count = testabilities.length; // No angular2 testability, this happens when\n        // going to a hybrid page and going back to a pure angular1 page\n\n        if (count === 0) {\n          return testCallback();\n        }\n\n        var decrement = function () {\n          count--;\n\n          if (count === 0) {\n            testCallback();\n          }\n        };\n\n        testabilities.forEach(function (testability) {\n          testability.whenStable(decrement);\n        });\n      } else {\n        testCallback();\n      } // not an angular2 app\n\n    };\n\n    if (!window.angular && !window.getAngularTestability) {\n      // no testability hook\n      throw new Error('both angularJS testability and angular testability are undefined.' + '  This could be either ' + 'because this is a non-angular page or because your test involves ' + 'client-side navigation, which can interfere with Protractor\\'s ' + 'bootstrapping.  See http://git.io/v4gXM for details');\n    } else {\n      waitForAngular1(waitForAngular2);\n    } // Wait for angular1 and angular2\n    // Testability hooks sequentially\n\n  } catch (err) {\n    callback(err.message);\n  }\n}\n\n;\n/* Tries to find $$testability and possibly $injector for an ng1 app\n *\n * By default, doesn't care about $injector if it finds $$testability.  However,\n * these priorities can be reversed.\n *\n * @param {string=} selector The selector for the element with the injector.  If\n *   falsy, tries a variety of methods to find an injector\n * @param {boolean=} injectorPlease Prioritize finding an injector\n * @return {$$testability?: Testability, $injector?: Injector} Returns whatever\n *   ng1 app hooks it finds\n */\n\nfunction getNg1Hooks(selector, injectorPlease) {\n  function tryEl(el) {\n    try {\n      if (!injectorPlease && angular.getTestability) {\n        var $$testability = angular.getTestability(el);\n\n        if ($$testability) {\n          return {\n            $$testability: $$testability\n          };\n        }\n      } else {\n        var $injector = angular.element(el).injector();\n\n        if ($injector) {\n          return {\n            $injector: $injector\n          };\n        }\n      }\n    } catch (err) {}\n  }\n\n  function trySelector(selector) {\n    var els = document.querySelectorAll(selector);\n\n    for (var i = 0; i < els.length; i++) {\n      var elHooks = tryEl(els[i]);\n\n      if (elHooks) {\n        return elHooks;\n      }\n    }\n  }\n\n  if (selector) {\n    return trySelector(selector);\n  } else if (window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__) {\n    var $injector = window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__;\n    var $$testability = null;\n\n    try {\n      $$testability = $injector.get('$$testability');\n    } catch (e) {}\n\n    return {\n      $injector: $injector,\n      $$testability: $$testability\n    };\n  } else {\n    return tryEl(document.body) || trySelector('[ng-app]') || trySelector('[ng\\\\:app]') || trySelector('[ng-controller]') || trySelector('[ng\\\\:controller]');\n  }\n}\n/* Wraps a function up into a string with its helper functions so that it can\n * call those helper functions client side\n *\n * @param {function} fun The function to wrap up with its helpers\n * @param {...function} The helper functions.  Each function must be named\n *\n * @return {string} The string which, when executed, will invoke fun in such a\n *   way that it has access to its helper functions\n */\n\n\nfunction wrapWithHelpers(fun) {\n  var helpers = Array.prototype.slice.call(arguments, 1);\n\n  if (!helpers.length) {\n    return fun;\n  }\n\n  var FunClass = Function; // Get the linter to allow this eval\n\n  return new FunClass(helpers.join(';') + String.fromCharCode(59) + '  return (' + fun.toString() + ').apply(this, arguments);');\n}\n\nexports.NG_WAIT_FN = wrapWithHelpers(waitForAngular, getNg1Hooks);","map":{"version":3,"names":["waitForAngular","rootSelector","callback","testCallback","waitForAngular1","window","angular","hooks","getNg1Hooks","$$testability","whenStable","$injector","get","notifyWhenNoOutstandingRequests","Error","location","toString","waitForAngular2","getAngularTestability","testability","el","document","querySelector","e","testabilities","getAllAngularTestabilities","count","length","decrement","forEach","err","message","selector","injectorPlease","tryEl","getTestability","element","injector","trySelector","els","querySelectorAll","i","elHooks","__TESTABILITY__NG1_APP_ROOT_INJECTOR__","body","wrapWithHelpers","fun","helpers","Array","prototype","slice","call","arguments","FunClass","Function","join","String","fromCharCode","exports","NG_WAIT_FN"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/blocking-proxy/built/lib/client_scripts/wait.js"],"sourcesContent":["/**\n * Copied from Protractor 5.2.0\n *\n * Wait until Angular has finished rendering and has\n * no outstanding $http calls before continuing. The specific Angular app\n * is determined by the rootSelector.\n *\n * Asynchronous.\n *\n * @param {string} rootSelector The selector housing an ng-app\n * @param {function(string)} callback callback. If a failure occurs, it will\n *     be passed as a parameter.\n */\nfunction waitForAngular(rootSelector, callback) {\n\n    try {\n      // Wait for both angular1 testability and angular2 testability.\n\n      var testCallback = callback;\n\n      // Wait for angular1 testability first and run waitForAngular2 as a callback\n      var waitForAngular1 = function(callback) {\n\n        if (window.angular) {\n          var hooks = getNg1Hooks(rootSelector);\n          if (!hooks){\n            callback();  // not an angular1 app\n          }\n          else{\n            if (hooks.$$testability) {\n              hooks.$$testability.whenStable(callback);\n            } else if (hooks.$injector) {\n              hooks.$injector.get('$browser')\n                  .notifyWhenNoOutstandingRequests(callback);\n            } else if (!!rootSelector) {\n              throw new Error(\n                  'Could not automatically find injector on page: \"' +\n                  window.location.toString() + '\".  Consider using config.rootEl');\n            } else {\n              throw new Error(\n                  'root element (' + rootSelector + ') has no injector.' +\n                  ' this may mean it is not inside ng-app.');\n            }\n          }\n        }\n        else {callback();}  // not an angular1 app\n      };\n\n      // Wait for Angular2 testability and then run test callback\n      var waitForAngular2 = function() {\n        if (window.getAngularTestability) {\n          if (rootSelector) {\n            var testability = null;\n            var el = document.querySelector(rootSelector);\n            try{\n              testability = window.getAngularTestability(el);\n            }\n            catch(e){}\n            if (testability) {\n              return testability.whenStable(testCallback);\n            }\n          }\n\n          // Didn't specify root element or testability could not be found\n          // by rootSelector. This may happen in a hybrid app, which could have\n          // more than one root.\n          var testabilities = window.getAllAngularTestabilities();\n          var count = testabilities.length;\n\n          // No angular2 testability, this happens when\n          // going to a hybrid page and going back to a pure angular1 page\n          if (count === 0) {\n            return testCallback();\n          }\n\n          var decrement = function() {\n            count--;\n            if (count === 0) {\n              testCallback();\n            }\n          };\n          testabilities.forEach(function(testability) {\n            testability.whenStable(decrement);\n          });\n\n        }\n        else {testCallback();}  // not an angular2 app\n      };\n\n      if (!(window.angular) && !(window.getAngularTestability)) {\n        // no testability hook\n        throw new Error(\n            'both angularJS testability and angular testability are undefined.' +\n            '  This could be either ' +\n            'because this is a non-angular page or because your test involves ' +\n            'client-side navigation, which can interfere with Protractor\\'s ' +\n            'bootstrapping.  See http://git.io/v4gXM for details');\n      } else {waitForAngular1(waitForAngular2);}  // Wait for angular1 and angular2\n                                                  // Testability hooks sequentially\n\n    } catch (err) {\n      callback(err.message);\n    }\n\n  };\n\n/* Tries to find $$testability and possibly $injector for an ng1 app\n *\n * By default, doesn't care about $injector if it finds $$testability.  However,\n * these priorities can be reversed.\n *\n * @param {string=} selector The selector for the element with the injector.  If\n *   falsy, tries a variety of methods to find an injector\n * @param {boolean=} injectorPlease Prioritize finding an injector\n * @return {$$testability?: Testability, $injector?: Injector} Returns whatever\n *   ng1 app hooks it finds\n */\nfunction getNg1Hooks(selector, injectorPlease) {\n  function tryEl(el) {\n    try {\n      if (!injectorPlease && angular.getTestability) {\n        var $$testability = angular.getTestability(el);\n        if ($$testability) {\n          return {$$testability: $$testability};\n        }\n      } else {\n        var $injector = angular.element(el).injector();\n        if ($injector) {\n          return {$injector: $injector};\n        }\n      }\n    } catch(err) {}\n  }\n  function trySelector(selector) {\n    var els = document.querySelectorAll(selector);\n    for (var i = 0; i < els.length; i++) {\n      var elHooks = tryEl(els[i]);\n      if (elHooks) {\n        return elHooks;\n      }\n    }\n  }\n\n  if (selector) {\n    return trySelector(selector);\n  } else if (window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__) {\n    var $injector = window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__;\n    var $$testability = null;\n    try {\n      $$testability = $injector.get('$$testability');\n    } catch (e) {}\n    return {$injector: $injector, $$testability: $$testability};\n  } else {\n    return tryEl(document.body) ||\n        trySelector('[ng-app]') || trySelector('[ng\\\\:app]') ||\n        trySelector('[ng-controller]') || trySelector('[ng\\\\:controller]');\n  }\n}\n\n/* Wraps a function up into a string with its helper functions so that it can\n * call those helper functions client side\n *\n * @param {function} fun The function to wrap up with its helpers\n * @param {...function} The helper functions.  Each function must be named\n *\n * @return {string} The string which, when executed, will invoke fun in such a\n *   way that it has access to its helper functions\n */\nfunction wrapWithHelpers(fun) {\n  var helpers = Array.prototype.slice.call(arguments, 1);\n  if (!helpers.length) {\n    return fun;\n  }\n  var FunClass = Function; // Get the linter to allow this eval\n  return new FunClass(\n      helpers.join(';') + String.fromCharCode(59) +\n      '  return (' + fun.toString() + ').apply(this, arguments);');\n}\n\nexports.NG_WAIT_FN = wrapWithHelpers(waitForAngular, getNg1Hooks);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}