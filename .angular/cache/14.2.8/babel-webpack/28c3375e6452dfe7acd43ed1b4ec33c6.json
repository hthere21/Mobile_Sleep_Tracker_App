{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\"); // Will use chalk if chalk is available to add color to console logging\n\n\nlet chalk;\nlet printRed;\nlet printYellow;\nlet printGray;\n\ntry {\n  chalk = require('chalk');\n  printRed = chalk.red;\n  printYellow = chalk.yellow;\n  printGray = chalk.gray;\n} catch (e) {\n  printRed = printYellow = printGray = msg => {\n    return msg;\n  };\n}\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n  LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n  LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n  LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\nvar WriteTo;\n\n(function (WriteTo) {\n  WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n  WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n  WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n  WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(WriteTo = exports.WriteTo || (exports.WriteTo = {}));\n\nlet logFile = 'protractor.log'; // the default log file name\n\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\n\nclass Logger {\n  /**\n   * Creates a logger instance with an ID for the logger.\n   * @constructor\n   */\n  constructor(id) {\n    this.id = id;\n  }\n  /**\n   * Set up the logging configuration from the protractor configuration file.\n   * @param config The protractor configuration\n   */\n\n\n  static set(config) {\n    if (config.troubleshoot) {\n      Logger.logLevel = LogLevel.DEBUG;\n    } else if (config.logLevel) {\n      Logger.logLevel = LogLevel[config.logLevel];\n    }\n  }\n  /**\n   * Set up the write location. If writing to a file, get the file descriptor.\n   * @param writeTo The enum for where to write the logs.\n   * @param opt_logFile An optional parameter to override the log file location.\n   */\n\n\n  static setWrite(writeTo, opt_logFile) {\n    if (opt_logFile) {\n      logFile = opt_logFile;\n    }\n\n    Logger.writeTo = writeTo;\n\n    if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n      Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n      Logger.firstWrite = false;\n    }\n  }\n  /**\n   * Log INFO\n   * @param ...msgs multiple arguments to be logged.\n   */\n\n\n  info(...msgs) {\n    this.log_(LogLevel.INFO, msgs);\n  }\n  /**\n   * Log DEBUG\n   * @param ...msgs multiple arguments to be logged.\n   */\n\n\n  debug(...msgs) {\n    this.log_(LogLevel.DEBUG, msgs);\n  }\n  /**\n   * Log WARN\n   * @param ...msgs multiple arguments to be logged.\n   */\n\n\n  warn(...msgs) {\n    this.log_(LogLevel.WARN, msgs);\n  }\n  /**\n   * Log ERROR\n   * @param ...msgs multiple arguments to be logged.\n   */\n\n\n  error(...msgs) {\n    this.log_(LogLevel.ERROR, msgs);\n  }\n  /**\n   * For the log level set, check to see if the messages should be logged.\n   * @param logLevel The log level of the message.\n   * @param msgs The messages to be logged\n   */\n\n\n  log_(logLevel, msgs) {\n    switch (Logger.logLevel) {\n      case LogLevel.ERROR:\n        if (logLevel <= LogLevel.ERROR) {\n          this.print_(logLevel, msgs);\n        }\n\n        break;\n\n      case LogLevel.WARN:\n        if (logLevel <= LogLevel.WARN) {\n          this.print_(logLevel, msgs);\n        }\n\n        break;\n\n      case LogLevel.INFO:\n        if (logLevel <= LogLevel.INFO) {\n          this.print_(logLevel, msgs);\n        }\n\n        break;\n\n      case LogLevel.DEBUG:\n        if (logLevel <= LogLevel.DEBUG) {\n          this.print_(logLevel, msgs);\n        }\n\n        break;\n\n      default:\n        throw new Error('Invalid log level');\n    }\n  }\n  /**\n   * Format with timestamp, log level, identifier, and message and log to\n   * specified medium (console, file, both, none).\n   * @param logLevel The log level of the message.\n   * @param msgs The messages to be logged.\n   */\n\n\n  print_(logLevel, msgs) {\n    let consoleLog = '';\n    let fileLog = '';\n\n    if (Logger.showTimestamp) {\n      consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n      fileLog += Logger.timestamp_(WriteTo.FILE);\n    }\n\n    consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n    fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n\n    if (Logger.showId) {\n      consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n      fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n    }\n\n    consoleLog += ' -';\n    fileLog += ' - ';\n\n    switch (Logger.writeTo) {\n      case WriteTo.CONSOLE:\n        msgs.unshift(consoleLog);\n        console.log.apply(console, msgs);\n        break;\n\n      case WriteTo.FILE:\n        // for the first line written to the file, add a space\n        if (!Logger.firstWrite) {\n          fs.writeSync(Logger.fd, '\\n');\n          Logger.firstWrite = true;\n        }\n\n        fileLog += ' ' + Logger.msgToFile_(msgs);\n        fs.writeSync(Logger.fd, fileLog + '\\n');\n        break;\n\n      case WriteTo.BOTH:\n        // for the first line written to the file, add a space\n        if (!Logger.firstWrite) {\n          fs.writeSync(Logger.fd, '\\n');\n          Logger.firstWrite = true;\n        }\n\n        fileLog += ' ' + Logger.msgToFile_(msgs);\n        fs.writeSync(Logger.fd, fileLog + '\\n');\n        msgs.unshift(consoleLog);\n        console.log.apply(console, msgs);\n        break;\n\n      case WriteTo.NONE:\n        break;\n    }\n  }\n  /**\n   * Get a timestamp formatted with [hh:mm:ss]\n   * @param writeTo The enum for where to write the logs.\n   * @return The string of the formatted timestamp\n   */\n\n\n  static timestamp_(writeTo) {\n    let d = new Date();\n    let ts = '[';\n    let hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n    let minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n    let seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n\n    if (writeTo == WriteTo.CONSOLE) {\n      ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n    } else {\n      ts += hours + ':' + minutes + ':' + seconds + ']';\n    }\n\n    ts += ' ';\n    return ts;\n  }\n  /**\n   * Get the identifier of the logger as '/<id>'\n   * @param logLevel The log level of the message.\n   * @param writeTo The enum for where to write the logs.\n   * @return The string of the formatted id\n   */\n\n\n  static id_(logLevel, id, writeTo) {\n    if (writeTo === WriteTo.FILE) {\n      return '/' + id;\n    } else if (logLevel === LogLevel.ERROR) {\n      return printRed('/' + id);\n    } else if (logLevel === LogLevel.WARN) {\n      return printYellow('/' + id);\n    } else {\n      return '/' + id;\n    }\n  }\n  /**\n   * Get the log level formatted with the first letter. For info, it is I.\n   * @param logLevel The log level of the message.\n   * @param writeTo The enum for where to write the logs.\n   * @return The string of the formatted log level\n   */\n\n\n  static level_(logLevel, id, writeTo) {\n    let level = LogLevel[logLevel].toString();\n\n    if (writeTo === WriteTo.FILE) {\n      return level[0];\n    } else if (logLevel === LogLevel.ERROR) {\n      return printRed(level[0]);\n    } else if (logLevel === LogLevel.WARN) {\n      return printYellow(level[0]);\n    } else {\n      return level[0];\n    }\n  }\n  /**\n   * Convert the list of messages to a single string message.\n   * @param msgs The list of messages.\n   * @return The string of the formatted messages\n   */\n\n\n  static msgToFile_(msgs) {\n    let log = '';\n\n    for (let pos = 0; pos < msgs.length; pos++) {\n      let msg = msgs[pos];\n      let ret;\n\n      if (typeof msg === 'object') {\n        ret = JSON.stringify(msg);\n      } else {\n        ret = msg;\n      }\n\n      if (pos !== msgs.length - 1) {\n        ret += ' ';\n      }\n\n      log += ret;\n    }\n\n    return log;\n  }\n\n}\n\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger;","map":{"version":3,"names":["Object","defineProperty","exports","value","fs","require","path","chalk","printRed","printYellow","printGray","red","yellow","gray","e","msg","LogLevel","WriteTo","logFile","Logger","constructor","id","set","config","troubleshoot","logLevel","DEBUG","setWrite","writeTo","opt_logFile","FILE","BOTH","fd","openSync","resolve","firstWrite","info","msgs","log_","INFO","debug","warn","WARN","error","ERROR","print_","Error","consoleLog","fileLog","showTimestamp","timestamp_","CONSOLE","level_","showId","id_","unshift","console","log","apply","writeSync","msgToFile_","NONE","d","Date","ts","hours","getHours","minutes","getMinutes","seconds","getSeconds","level","toString","pos","length","ret","JSON","stringify"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/protractor/built/logger.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n// Will use chalk if chalk is available to add color to console logging\nlet chalk;\nlet printRed;\nlet printYellow;\nlet printGray;\ntry {\n    chalk = require('chalk');\n    printRed = chalk.red;\n    printYellow = chalk.yellow;\n    printGray = chalk.gray;\n}\ncatch (e) {\n    printRed = printYellow = printGray = (msg) => {\n        return msg;\n    };\n}\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\nvar WriteTo;\n(function (WriteTo) {\n    WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n    WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n    WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n    WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(WriteTo = exports.WriteTo || (exports.WriteTo = {}));\nlet logFile = 'protractor.log'; // the default log file name\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\nclass Logger {\n    /**\n     * Creates a logger instance with an ID for the logger.\n     * @constructor\n     */\n    constructor(id) {\n        this.id = id;\n    }\n    /**\n     * Set up the logging configuration from the protractor configuration file.\n     * @param config The protractor configuration\n     */\n    static set(config) {\n        if (config.troubleshoot) {\n            Logger.logLevel = LogLevel.DEBUG;\n        }\n        else if (config.logLevel) {\n            Logger.logLevel = LogLevel[config.logLevel];\n        }\n    }\n    /**\n     * Set up the write location. If writing to a file, get the file descriptor.\n     * @param writeTo The enum for where to write the logs.\n     * @param opt_logFile An optional parameter to override the log file location.\n     */\n    static setWrite(writeTo, opt_logFile) {\n        if (opt_logFile) {\n            logFile = opt_logFile;\n        }\n        Logger.writeTo = writeTo;\n        if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n            Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n            Logger.firstWrite = false;\n        }\n    }\n    /**\n     * Log INFO\n     * @param ...msgs multiple arguments to be logged.\n     */\n    info(...msgs) {\n        this.log_(LogLevel.INFO, msgs);\n    }\n    /**\n     * Log DEBUG\n     * @param ...msgs multiple arguments to be logged.\n     */\n    debug(...msgs) {\n        this.log_(LogLevel.DEBUG, msgs);\n    }\n    /**\n     * Log WARN\n     * @param ...msgs multiple arguments to be logged.\n     */\n    warn(...msgs) {\n        this.log_(LogLevel.WARN, msgs);\n    }\n    /**\n     * Log ERROR\n     * @param ...msgs multiple arguments to be logged.\n     */\n    error(...msgs) {\n        this.log_(LogLevel.ERROR, msgs);\n    }\n    /**\n     * For the log level set, check to see if the messages should be logged.\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged\n     */\n    log_(logLevel, msgs) {\n        switch (Logger.logLevel) {\n            case LogLevel.ERROR:\n                if (logLevel <= LogLevel.ERROR) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.WARN:\n                if (logLevel <= LogLevel.WARN) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.INFO:\n                if (logLevel <= LogLevel.INFO) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.DEBUG:\n                if (logLevel <= LogLevel.DEBUG) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            default:\n                throw new Error('Invalid log level');\n        }\n    }\n    /**\n     * Format with timestamp, log level, identifier, and message and log to\n     * specified medium (console, file, both, none).\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged.\n     */\n    print_(logLevel, msgs) {\n        let consoleLog = '';\n        let fileLog = '';\n        if (Logger.showTimestamp) {\n            consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n            fileLog += Logger.timestamp_(WriteTo.FILE);\n        }\n        consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n        fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n        if (Logger.showId) {\n            consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n            fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n        }\n        consoleLog += ' -';\n        fileLog += ' - ';\n        switch (Logger.writeTo) {\n            case WriteTo.CONSOLE:\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.FILE:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                break;\n            case WriteTo.BOTH:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.NONE:\n                break;\n        }\n    }\n    /**\n     * Get a timestamp formatted with [hh:mm:ss]\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted timestamp\n     */\n    static timestamp_(writeTo) {\n        let d = new Date();\n        let ts = '[';\n        let hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n        let minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n        let seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n        if (writeTo == WriteTo.CONSOLE) {\n            ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n        }\n        else {\n            ts += hours + ':' + minutes + ':' + seconds + ']';\n        }\n        ts += ' ';\n        return ts;\n    }\n    /**\n     * Get the identifier of the logger as '/<id>'\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted id\n     */\n    static id_(logLevel, id, writeTo) {\n        if (writeTo === WriteTo.FILE) {\n            return '/' + id;\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed('/' + id);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow('/' + id);\n        }\n        else {\n            return '/' + id;\n        }\n    }\n    /**\n     * Get the log level formatted with the first letter. For info, it is I.\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted log level\n     */\n    static level_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return level[0];\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed(level[0]);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow(level[0]);\n        }\n        else {\n            return level[0];\n        }\n    }\n    /**\n     * Convert the list of messages to a single string message.\n     * @param msgs The list of messages.\n     * @return The string of the formatted messages\n     */\n    static msgToFile_(msgs) {\n        let log = '';\n        for (let pos = 0; pos < msgs.length; pos++) {\n            let msg = msgs[pos];\n            let ret;\n            if (typeof msg === 'object') {\n                ret = JSON.stringify(msg);\n            }\n            else {\n                ret = msg;\n            }\n            if (pos !== msgs.length - 1) {\n                ret += ' ';\n            }\n            log += ret;\n        }\n        return log;\n    }\n}\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}