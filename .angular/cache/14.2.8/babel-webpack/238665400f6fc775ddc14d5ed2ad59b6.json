{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/** @fileoverview Utilities for working with Firefox extensions. */\n'use strict';\n\nconst fs = require('fs'),\n      path = require('path'),\n      xml = require('xml2js');\n\nconst io = require('../io');\n\nconst zip = require('../io/zip');\n/**\n * Thrown when there an add-on is malformed.\n */\n\n\nclass AddonFormatError extends Error {\n  /** @param {string} msg The error message. */\n  constructor(msg) {\n    super(msg);\n    /** @override */\n\n    this.name = this.constructor.name;\n  }\n\n}\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the extension to install, as either a xpi\n *     file or a directory.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!Promise<string>} A promise for the add-on ID once\n *     installed.\n */\n\n\nfunction install(extension, dir) {\n  return getDetails(extension).then(function (details) {\n    var dst = path.join(dir, details.id);\n\n    if (extension.slice(-4) === '.xpi') {\n      if (!details.unpack) {\n        return io.copy(extension, dst + '.xpi').then(() => details.id);\n      } else {\n        return zip.unzip(extension, dst).then(() => details.id);\n      }\n    } else {\n      return io.copyDir(extension, dst).then(() => details.id);\n    }\n  });\n}\n/**\n * Describes a Firefox add-on.\n * @typedef {{id: string, name: string, version: string, unpack: boolean}}\n */\n\n\nvar AddonDetails;\n/** @typedef {{$: !Object<string, string>}} */\n\nvar RdfRoot;\n/**\n * Extracts the details needed to install an add-on.\n * @param {string} addonPath Path to the extension directory.\n * @return {!Promise<!AddonDetails>} A promise for the add-on details.\n */\n\nfunction getDetails(addonPath) {\n  return io.stat(addonPath).then(stats => {\n    if (stats.isDirectory()) {\n      return parseDirectory(addonPath);\n    } else if (addonPath.slice(-4) === '.xpi') {\n      return parseXpiFile(addonPath);\n    } else {\n      throw Error('Add-on path is not an xpi or a directory: ' + addonPath);\n    }\n  });\n  /**\n   * Parse an install.rdf for a Firefox add-on.\n   * @param {string} rdf The contents of install.rdf for the add-on.\n   * @return {!Promise<!AddonDetails>} A promise for the add-on details.\n   */\n\n  function parseInstallRdf(rdf) {\n    return parseXml(rdf).then(function (doc) {\n      var em = getNamespaceId(doc, 'http://www.mozilla.org/2004/em-rdf#');\n      var rdf = getNamespaceId(doc, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');\n      var description = doc[rdf + 'RDF'][rdf + 'Description'][0];\n      var details = {\n        id: getNodeText(description, em + 'id'),\n        name: getNodeText(description, em + 'name'),\n        version: getNodeText(description, em + 'version'),\n        unpack: getNodeText(description, em + 'unpack') || false\n      };\n\n      if (typeof details.unpack === 'string') {\n        details.unpack = details.unpack.toLowerCase() === 'true';\n      }\n\n      if (!details.id) {\n        throw new AddonFormatError('Could not find add-on ID for ' + addonPath);\n      }\n\n      return details;\n    });\n\n    function parseXml(text) {\n      return new Promise((resolve, reject) => {\n        xml.parseString(text, (err, data) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n\n    function getNodeText(node, name) {\n      return node[name] && node[name][0] || '';\n    }\n\n    function getNamespaceId(doc, url) {\n      var keys = Object.keys(doc);\n\n      if (keys.length !== 1) {\n        throw new AddonFormatError('Malformed manifest for add-on ' + addonPath);\n      }\n\n      var namespaces =\n      /** @type {!RdfRoot} */\n      doc[keys[0]].$;\n      var id = '';\n      Object.keys(namespaces).some(function (ns) {\n        if (namespaces[ns] !== url) {\n          return false;\n        }\n\n        if (ns.indexOf(':') != -1) {\n          id = ns.split(':')[1] + ':';\n        }\n\n        return true;\n      });\n      return id;\n    }\n  }\n  /**\n   * Parse a manifest for a Firefox WebExtension.\n   * @param {{\n   *   name: string,\n   *   version: string,\n   *   applications: {gecko:{id:string}}\n   * }} json JSON representation of the manifest.\n   * @return {!AddonDetails} The add-on details.\n   */\n\n\n  function parseManifestJson({\n    name,\n    version,\n    applications\n  }) {\n    if (!(applications && applications.gecko && applications.gecko.id)) {\n      throw new AddonFormatError('Could not find add-on ID for ' + addonPath);\n    }\n\n    return {\n      id: applications.gecko.id,\n      name,\n      version,\n      unpack: false\n    };\n  }\n\n  function parseXpiFile(filePath) {\n    return zip.load(filePath).then(archive => {\n      if (archive.has('install.rdf')) {\n        return archive.getFile('install.rdf').then(buf => parseInstallRdf(buf.toString('utf8')));\n      }\n\n      if (archive.has('manifest.json')) {\n        return archive.getFile('manifest.json').then(buf => JSON.parse(buf.toString('utf8'))).then(parseManifestJson);\n      }\n\n      throw new AddonFormatError(`Couldn't find install.rdf or manifest.json in ${filePath}`);\n    });\n  }\n\n  function parseDirectory(dirPath) {\n    const rdfPath = path.join(dirPath, 'install.rdf');\n    const jsonPath = path.join(dirPath, 'manifest.json');\n    return io.exists(rdfPath).then(rdfExists => {\n      if (rdfExists) {\n        return io.read(rdfPath).then(buf => parseInstallRdf(buf.toString('utf8')));\n      }\n\n      return io.exists(jsonPath).then(jsonExists => {\n        if (jsonExists) {\n          return io.read(jsonPath).then(buf => JSON.parse(buf.toString('utf8'))).then(parseManifestJson);\n        }\n\n        throw new AddonFormatError(`Couldn't find install.rdf or manifest.json in ${dirPath}`);\n      });\n    });\n  }\n} // PUBLIC API\n\n\nexports.install = install;","map":{"version":3,"names":["fs","require","path","xml","io","zip","AddonFormatError","Error","constructor","msg","name","install","extension","dir","getDetails","then","details","dst","join","id","slice","unpack","copy","unzip","copyDir","AddonDetails","RdfRoot","addonPath","stat","stats","isDirectory","parseDirectory","parseXpiFile","parseInstallRdf","rdf","parseXml","doc","em","getNamespaceId","description","getNodeText","version","toLowerCase","text","Promise","resolve","reject","parseString","err","data","node","url","keys","Object","length","namespaces","$","some","ns","indexOf","split","parseManifestJson","applications","gecko","filePath","load","archive","has","getFile","buf","toString","JSON","parse","dirPath","rdfPath","jsonPath","exists","rdfExists","read","jsonExists","exports"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/selenium-webdriver/firefox/extension.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/** @fileoverview Utilities for working with Firefox extensions. */\n\n'use strict';\n\nconst fs = require('fs'),\n    path = require('path'),\n    xml = require('xml2js');\n\nconst io = require('../io');\nconst zip = require('../io/zip');\n\n\n/**\n * Thrown when there an add-on is malformed.\n */\nclass AddonFormatError extends Error {\n  /** @param {string} msg The error message. */\n  constructor(msg) {\n    super(msg);\n    /** @override */\n    this.name = this.constructor.name;\n  }\n}\n\n\n\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the extension to install, as either a xpi\n *     file or a directory.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!Promise<string>} A promise for the add-on ID once\n *     installed.\n */\nfunction install(extension, dir) {\n  return getDetails(extension).then(function(details) {\n    var dst = path.join(dir, details.id);\n    if (extension.slice(-4) === '.xpi') {\n      if (!details.unpack) {\n        return io.copy(extension, dst + '.xpi').then(() => details.id);\n      } else {\n        return zip.unzip(extension, dst).then(() => details.id);\n      }\n    } else {\n      return io.copyDir(extension, dst).then(() => details.id);\n    }\n  });\n}\n\n\n/**\n * Describes a Firefox add-on.\n * @typedef {{id: string, name: string, version: string, unpack: boolean}}\n */\nvar AddonDetails;\n\n/** @typedef {{$: !Object<string, string>}} */\nvar RdfRoot;\n\n\n/**\n * Extracts the details needed to install an add-on.\n * @param {string} addonPath Path to the extension directory.\n * @return {!Promise<!AddonDetails>} A promise for the add-on details.\n */\nfunction getDetails(addonPath) {\n  return io.stat(addonPath).then((stats) => {\n    if (stats.isDirectory()) {\n      return parseDirectory(addonPath);\n    } else if (addonPath.slice(-4) === '.xpi') {\n      return parseXpiFile(addonPath);\n    } else {\n      throw Error('Add-on path is not an xpi or a directory: ' + addonPath);\n    }\n  });\n\n  /**\n   * Parse an install.rdf for a Firefox add-on.\n   * @param {string} rdf The contents of install.rdf for the add-on.\n   * @return {!Promise<!AddonDetails>} A promise for the add-on details.\n   */\n  function parseInstallRdf(rdf) {\n    return parseXml(rdf).then(function(doc) {\n      var em = getNamespaceId(doc, 'http://www.mozilla.org/2004/em-rdf#');\n      var rdf = getNamespaceId(\n          doc, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');\n\n      var description = doc[rdf + 'RDF'][rdf + 'Description'][0];\n      var details = {\n        id: getNodeText(description, em + 'id'),\n        name: getNodeText(description, em + 'name'),\n        version: getNodeText(description, em + 'version'),\n        unpack: getNodeText(description, em + 'unpack') || false\n      };\n\n      if (typeof details.unpack === 'string') {\n        details.unpack = details.unpack.toLowerCase() === 'true';\n      }\n\n      if (!details.id) {\n        throw new AddonFormatError('Could not find add-on ID for ' + addonPath);\n      }\n\n      return details;\n    });\n\n    function parseXml(text) {\n      return new Promise((resolve, reject) => {\n        xml.parseString(text, (err, data) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n\n    function getNodeText(node, name) {\n      return node[name] && node[name][0] || '';\n    }\n\n    function getNamespaceId(doc, url) {\n      var keys = Object.keys(doc);\n      if (keys.length !== 1) {\n        throw new AddonFormatError('Malformed manifest for add-on ' + addonPath);\n      }\n\n      var namespaces = /** @type {!RdfRoot} */(doc[keys[0]]).$;\n      var id = '';\n      Object.keys(namespaces).some(function(ns) {\n        if (namespaces[ns] !== url) {\n          return false;\n        }\n\n        if (ns.indexOf(':') != -1) {\n          id = ns.split(':')[1] + ':';\n        }\n        return true;\n      });\n      return id;\n    }\n  }\n\n  /**\n   * Parse a manifest for a Firefox WebExtension.\n   * @param {{\n   *   name: string,\n   *   version: string,\n   *   applications: {gecko:{id:string}}\n   * }} json JSON representation of the manifest.\n   * @return {!AddonDetails} The add-on details.\n   */\n  function parseManifestJson({name, version, applications}) {\n    if (!(applications && applications.gecko && applications.gecko.id)) {\n      throw new AddonFormatError('Could not find add-on ID for ' + addonPath);\n    }\n\n    return {id: applications.gecko.id, name, version, unpack: false};\n  }\n\n  function parseXpiFile(filePath) {\n    return zip.load(filePath).then(archive => {\n      if (archive.has('install.rdf')) {\n        return archive.getFile('install.rdf')\n            .then(buf => parseInstallRdf(buf.toString('utf8')));\n      }\n\n      if (archive.has('manifest.json')) {\n        return archive.getFile('manifest.json')\n            .then(buf => JSON.parse(buf.toString('utf8')))\n            .then(parseManifestJson);\n      }\n\n      throw new AddonFormatError(\n          `Couldn't find install.rdf or manifest.json in ${filePath}`);\n    });\n  }\n\n  function parseDirectory(dirPath) {\n    const rdfPath = path.join(dirPath, 'install.rdf');\n    const jsonPath = path.join(dirPath, 'manifest.json');\n    return io.exists(rdfPath)\n        .then(rdfExists => {\n          if (rdfExists) {\n            return io.read(rdfPath)\n                .then(buf => parseInstallRdf(buf.toString('utf8')));\n          }\n          return io.exists(jsonPath)\n              .then(jsonExists => {\n                if (jsonExists) {\n                  return io.read(jsonPath)\n                      .then(buf => JSON.parse(buf.toString('utf8')))\n                      .then(parseManifestJson);\n                }\n                throw new AddonFormatError(\n                    `Couldn't find install.rdf or manifest.json in ${dirPath}`);\n              });\n        })\n  }\n}\n\n\n// PUBLIC API\n\n\nexports.install = install;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}