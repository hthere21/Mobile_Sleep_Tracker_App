{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http = require(\"http\");\n\nconst url = require(\"url\");\n\nconst blockingproxy_1 = require(\"./blockingproxy\");\n\nclass BPClient {\n  constructor(bpUrlValue) {\n    let bpUrl = url.parse(bpUrlValue);\n    this.hostname = bpUrl.hostname;\n    this.port = parseInt(bpUrl.port);\n  }\n  /**\n   * Toggle whether waiting for Angular is enabled.\n   *\n   * @param enabled Whether or not to enable waiting for angular.\n   * @returns {Promise<T>}\n   */\n\n\n  setWaitEnabled(enabled) {\n    return new Promise((resolve, reject) => {\n      let options = {\n        host: this.hostname,\n        port: this.port,\n        method: 'POST',\n        path: `/${blockingproxy_1.BP_PREFIX}/waitEnabled`\n      };\n      let request = http.request(options, response => {\n        response.on('data', () => {});\n        response.on('error', err => reject(err));\n        response.on('end', () => {\n          resolve();\n        });\n      });\n      request.write(JSON.stringify({\n        value: enabled\n      }));\n      request.end();\n    });\n  }\n  /**\n   * Set the selector used to find the root element of the Angular application to wait for. See\n   * AngularWaitBarrier for more details.\n   *\n   * @param selector A selector, or empty string to wait for all Angular apps.\n   */\n\n\n  setWaitParams(rootSelector) {\n    return new Promise((resolve, reject) => {\n      let options = {\n        host: this.hostname,\n        port: this.port,\n        method: 'POST',\n        path: `/${blockingproxy_1.BP_PREFIX}/waitParams`\n      };\n      let request = http.request(options, response => {\n        response.on('data', () => {});\n        response.on('error', err => reject(err));\n        response.on('end', () => {\n          resolve();\n        });\n      });\n      request.write(JSON.stringify({\n        rootSelector: rootSelector\n      }));\n      request.end();\n    });\n  }\n\n  isWaitEnabled() {\n    return new Promise(res => {\n      let options = {\n        host: this.hostname,\n        port: this.port,\n        path: `/${blockingproxy_1.BP_PREFIX}/waitEnabled`\n      };\n      http.get(options, response => {\n        let body = '';\n        response.on('data', data => {\n          body += data;\n        });\n        response.on('end', () => {\n          res(JSON.parse(body).value);\n        });\n      });\n    });\n  }\n\n}\n\nexports.BPClient = BPClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","http","require","url","blockingproxy_1","BPClient","constructor","bpUrlValue","bpUrl","parse","hostname","port","parseInt","setWaitEnabled","enabled","Promise","resolve","reject","options","host","method","path","BP_PREFIX","request","response","on","err","write","JSON","stringify","end","setWaitParams","rootSelector","isWaitEnabled","res","get","body","data"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/blocking-proxy/built/lib/client.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst blockingproxy_1 = require(\"./blockingproxy\");\nclass BPClient {\n    constructor(bpUrlValue) {\n        let bpUrl = url.parse(bpUrlValue);\n        this.hostname = bpUrl.hostname;\n        this.port = parseInt(bpUrl.port);\n    }\n    /**\n     * Toggle whether waiting for Angular is enabled.\n     *\n     * @param enabled Whether or not to enable waiting for angular.\n     * @returns {Promise<T>}\n     */\n    setWaitEnabled(enabled) {\n        return new Promise((resolve, reject) => {\n            let options = { host: this.hostname, port: this.port, method: 'POST', path: `/${blockingproxy_1.BP_PREFIX}/waitEnabled` };\n            let request = http.request(options, (response) => {\n                response.on('data', () => { });\n                response.on('error', (err) => reject(err));\n                response.on('end', () => {\n                    resolve();\n                });\n            });\n            request.write(JSON.stringify({ value: enabled }));\n            request.end();\n        });\n    }\n    /**\n     * Set the selector used to find the root element of the Angular application to wait for. See\n     * AngularWaitBarrier for more details.\n     *\n     * @param selector A selector, or empty string to wait for all Angular apps.\n     */\n    setWaitParams(rootSelector) {\n        return new Promise((resolve, reject) => {\n            let options = { host: this.hostname, port: this.port, method: 'POST', path: `/${blockingproxy_1.BP_PREFIX}/waitParams` };\n            let request = http.request(options, (response) => {\n                response.on('data', () => { });\n                response.on('error', (err) => reject(err));\n                response.on('end', () => {\n                    resolve();\n                });\n            });\n            request.write(JSON.stringify({ rootSelector: rootSelector }));\n            request.end();\n        });\n    }\n    isWaitEnabled() {\n        return new Promise((res) => {\n            let options = { host: this.hostname, port: this.port, path: `/${blockingproxy_1.BP_PREFIX}/waitEnabled` };\n            http.get(options, (response) => {\n                let body = '';\n                response.on('data', (data) => {\n                    body += data;\n                });\n                response.on('end', () => {\n                    res(JSON.parse(body).value);\n                });\n            });\n        });\n    }\n}\nexports.BPClient = BPClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}