{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nvar os = require('os');\n\nfunction getLoInterface() {\n  var name;\n\n  if (process.platform === 'darwin') {\n    name = 'lo0';\n  } else if (process.platform === 'linux') {\n    name = 'lo';\n  }\n\n  return name ? os.networkInterfaces()[name] : null;\n}\n/**\n * Queries the system network interfaces for an IP address.\n * @param {boolean} loopback Whether to find a loopback address.\n * @param {string=} opt_family The IP family (IPv4 or IPv6). Defaults to IPv4.\n * @return {string} The located IP address or undefined.\n */\n\n\nfunction getAddress(loopback, opt_family) {\n  var family = opt_family || 'IPv4';\n  var addresses = [];\n  var interfaces;\n\n  if (loopback) {\n    var lo = getLoInterface();\n    interfaces = lo ? [lo] : null;\n  }\n\n  interfaces = interfaces || os.networkInterfaces();\n\n  for (var key in interfaces) {\n    if (!interfaces.hasOwnProperty(key)) {\n      continue;\n    }\n\n    interfaces[key].forEach(function (ipAddress) {\n      if (ipAddress.family === family && ipAddress.internal === loopback) {\n        addresses.push(ipAddress.address);\n      }\n    });\n  }\n\n  return addresses[0];\n} // PUBLIC API\n\n/**\n * Retrieves the external IP address for this host.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\n\n\nexports.getAddress = function (opt_family) {\n  return getAddress(false, opt_family);\n};\n/**\n * Retrieves a loopback address for this machine.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\n\n\nexports.getLoopbackAddress = function (opt_family) {\n  return getAddress(true, opt_family);\n};\n/**\n * Splits a hostport string, e.g. \"www.example.com:80\", into its component\n * parts.\n *\n * @param {string} hostport The string to split.\n * @return {{host: string, port: ?number}} A host and port. If no port is\n *     present in the argument `hostport`, port is null.\n */\n\n\nexports.splitHostAndPort = function (hostport) {\n  let lastIndex = hostport.lastIndexOf(':');\n\n  if (lastIndex < 0) {\n    return {\n      host: hostport,\n      port: null\n    };\n  }\n\n  let firstIndex = hostport.indexOf(':');\n\n  if (firstIndex != lastIndex && !hostport.includes('[')) {\n    // Multiple colons but no brackets, so assume the string is an IPv6 address\n    // with no port (e.g. \"1234:5678:9:0:1234:5678:9:0\").\n    return {\n      host: hostport,\n      port: null\n    };\n  }\n\n  let host = hostport.slice(0, lastIndex);\n\n  if (host.startsWith('[') && host.endsWith(']')) {\n    host = host.slice(1, -1);\n  }\n\n  let port = parseInt(hostport.slice(lastIndex + 1), 10);\n  return {\n    host,\n    port\n  };\n};","map":{"version":3,"names":["os","require","getLoInterface","name","process","platform","networkInterfaces","getAddress","loopback","opt_family","family","addresses","interfaces","lo","key","hasOwnProperty","forEach","ipAddress","internal","push","address","exports","getLoopbackAddress","splitHostAndPort","hostport","lastIndex","lastIndexOf","host","port","firstIndex","indexOf","includes","slice","startsWith","endsWith","parseInt"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/selenium-webdriver/net/index.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\nvar os = require('os');\n\n\nfunction getLoInterface() {\n  var name;\n  if (process.platform === 'darwin') {\n    name = 'lo0';\n  } else if (process.platform === 'linux') {\n    name = 'lo';\n  }\n  return name ? os.networkInterfaces()[name] : null;\n}\n\n\n/**\n * Queries the system network interfaces for an IP address.\n * @param {boolean} loopback Whether to find a loopback address.\n * @param {string=} opt_family The IP family (IPv4 or IPv6). Defaults to IPv4.\n * @return {string} The located IP address or undefined.\n */\nfunction getAddress(loopback, opt_family) {\n  var family = opt_family || 'IPv4';\n  var addresses = [];\n\n  var interfaces;\n  if (loopback) {\n    var lo = getLoInterface();\n    interfaces = lo ? [lo] : null;\n  }\n  interfaces = interfaces || os.networkInterfaces();\n  for (var key in interfaces) {\n    if (!interfaces.hasOwnProperty(key)) {\n      continue;\n    }\n\n    interfaces[key].forEach(function(ipAddress) {\n      if (ipAddress.family === family &&\n          ipAddress.internal === loopback) {\n        addresses.push(ipAddress.address);\n      }\n    });\n  }\n  return addresses[0];\n}\n\n\n// PUBLIC API\n\n\n/**\n * Retrieves the external IP address for this host.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\nexports.getAddress = function(opt_family) {\n  return getAddress(false, opt_family);\n};\n\n\n/**\n * Retrieves a loopback address for this machine.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\nexports.getLoopbackAddress = function(opt_family) {\n  return getAddress(true, opt_family);\n};\n\n\n/**\n * Splits a hostport string, e.g. \"www.example.com:80\", into its component\n * parts.\n *\n * @param {string} hostport The string to split.\n * @return {{host: string, port: ?number}} A host and port. If no port is\n *     present in the argument `hostport`, port is null.\n */\nexports.splitHostAndPort = function(hostport) {\n  let lastIndex = hostport.lastIndexOf(':');\n  if (lastIndex < 0) {\n    return {host: hostport, port: null};\n  }\n\n  let firstIndex = hostport.indexOf(':');\n  if (firstIndex != lastIndex && !hostport.includes('[')) {\n    // Multiple colons but no brackets, so assume the string is an IPv6 address\n    // with no port (e.g. \"1234:5678:9:0:1234:5678:9:0\").\n    return {host: hostport, port: null};\n  }\n\n  let host = hostport.slice(0, lastIndex);\n  if (host.startsWith('[') && host.endsWith(']')) {\n    host = host.slice(1, -1);\n  }\n\n  let port = parseInt(hostport.slice(lastIndex + 1), 10);\n  return {host, port};\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}