{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst webdriver_logger_1 = require(\"./webdriver_logger\");\n\nconst angularWaits = require('./client_scripts/wait.js');\n/**\n * A barrier that uses Angular's Testability API to block commands until the application is stable.\n */\n\n\nclass AngularWaitBarrier {\n  constructor(client) {\n    this.client = client;\n    this.enabled = true;\n    this.rootSelector = '';\n  }\n  /**\n   * A CSS Selector for a DOM element within your Angular application.\n   * BlockingProxy will attempt to automatically find your application, but it is\n   * necessary to set rootElement in certain cases.\n   *\n   * In Angular 1, BlockingProxy will use the element your app bootstrapped to by\n   * default.  If that doesn't work, it will then search for hooks in `body` or\n   * `ng-app` elements (details here: https://git.io/v1b2r).\n   *\n   * In later versions of Angular, BlockingProxy will try to hook into all angular\n   * apps on the page. Use rootElement to limit the scope of which apps\n   * BlockingProxy waits for and searches within.\n   *\n   * @param rootSelector A selector for the root element of the Angular app.\n   */\n\n\n  setRootSelector(selector) {\n    this.rootSelector = selector;\n  }\n\n  waitForAngularData() {\n    return JSON.stringify({\n      script: 'return (' + angularWaits.NG_WAIT_FN + ').apply(null, arguments);',\n      args: [this.rootSelector]\n    });\n  }\n  /**\n   * Turn on WebDriver logging.\n   *\n   * @param logDir The directory to create logs in.\n   */\n\n\n  enableLogging(logDir) {\n    if (!this.logger) {\n      this.logger = new webdriver_logger_1.WebDriverLogger();\n    }\n\n    this.logger.setLogDir(logDir);\n  }\n  /**\n   * Override the logger instance. Only used for testing.\n   */\n\n\n  setLogger(logger) {\n    this.logger = logger;\n  }\n\n  sendRequestToStabilize(command) {\n    return this.client.executeAsync(command.sessionId, this.waitForAngularData()).then(value => {\n      // waitForAngular only returns a value if there was an error\n      // in the browser.\n      if (value) {\n        throw new Error('Error from waitForAngular: ' + value);\n      }\n    });\n  }\n\n  shouldStabilize(command) {\n    const url = command.url;\n\n    if (!this.enabled) {\n      return false;\n    } // TODO - should this implement some state, and be smart about whether\n    // stabilization is necessary or not? Would that be as simple as GET/POST?\n    // e.g. two gets in a row don't require a wait btwn.\n    //\n    // See https://code.google.com/p/selenium/wiki/JsonWireProtocol for\n    // descriptions of the paths.\n    // We shouldn't stabilize if we haven't loaded the page yet.\n\n\n    const parts = url.split('/');\n\n    if (parts.length < 4) {\n      return false;\n    }\n\n    const commandsToWaitFor = ['executeScript', 'screenshot', 'source', 'title', 'element', 'elements', 'execute', 'keys', 'moveto', 'click', 'buttondown', 'buttonup', 'doubleclick', 'touch', 'get'];\n\n    if (commandsToWaitFor.indexOf(parts[3]) != -1) {\n      return true;\n    }\n\n    return false;\n  }\n\n  onCommand(command) {\n    if (this.logger) {\n      command.on('data', () => {\n        this.logger.logWebDriverCommand(command);\n      });\n    }\n\n    if (this.shouldStabilize(command)) {\n      const started = Date.now();\n      return this.sendRequestToStabilize(command).then(() => {\n        const ended = Date.now();\n\n        if (this.logger) {\n          this.logger.logEvent('Waiting for Angular', command.sessionId, ended - started);\n        }\n      });\n    }\n\n    return Promise.resolve(null);\n  }\n\n}\n\nexports.AngularWaitBarrier = AngularWaitBarrier;","map":{"version":3,"names":["Object","defineProperty","exports","value","webdriver_logger_1","require","angularWaits","AngularWaitBarrier","constructor","client","enabled","rootSelector","setRootSelector","selector","waitForAngularData","JSON","stringify","script","NG_WAIT_FN","args","enableLogging","logDir","logger","WebDriverLogger","setLogDir","setLogger","sendRequestToStabilize","command","executeAsync","sessionId","then","Error","shouldStabilize","url","parts","split","length","commandsToWaitFor","indexOf","onCommand","on","logWebDriverCommand","started","Date","now","ended","logEvent","Promise","resolve"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/blocking-proxy/built/lib/angular_wait_barrier.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst webdriver_logger_1 = require(\"./webdriver_logger\");\nconst angularWaits = require('./client_scripts/wait.js');\n/**\n * A barrier that uses Angular's Testability API to block commands until the application is stable.\n */\nclass AngularWaitBarrier {\n    constructor(client) {\n        this.client = client;\n        this.enabled = true;\n        this.rootSelector = '';\n    }\n    /**\n     * A CSS Selector for a DOM element within your Angular application.\n     * BlockingProxy will attempt to automatically find your application, but it is\n     * necessary to set rootElement in certain cases.\n     *\n     * In Angular 1, BlockingProxy will use the element your app bootstrapped to by\n     * default.  If that doesn't work, it will then search for hooks in `body` or\n     * `ng-app` elements (details here: https://git.io/v1b2r).\n     *\n     * In later versions of Angular, BlockingProxy will try to hook into all angular\n     * apps on the page. Use rootElement to limit the scope of which apps\n     * BlockingProxy waits for and searches within.\n     *\n     * @param rootSelector A selector for the root element of the Angular app.\n     */\n    setRootSelector(selector) {\n        this.rootSelector = selector;\n    }\n    waitForAngularData() {\n        return JSON.stringify({\n            script: 'return (' + angularWaits.NG_WAIT_FN + ').apply(null, arguments);',\n            args: [this.rootSelector]\n        });\n    }\n    /**\n     * Turn on WebDriver logging.\n     *\n     * @param logDir The directory to create logs in.\n     */\n    enableLogging(logDir) {\n        if (!this.logger) {\n            this.logger = new webdriver_logger_1.WebDriverLogger();\n        }\n        this.logger.setLogDir(logDir);\n    }\n    /**\n     * Override the logger instance. Only used for testing.\n     */\n    setLogger(logger) {\n        this.logger = logger;\n    }\n    sendRequestToStabilize(command) {\n        return this.client.executeAsync(command.sessionId, this.waitForAngularData()).then((value) => {\n            // waitForAngular only returns a value if there was an error\n            // in the browser.\n            if (value) {\n                throw new Error('Error from waitForAngular: ' + value);\n            }\n        });\n    }\n    shouldStabilize(command) {\n        const url = command.url;\n        if (!this.enabled) {\n            return false;\n        }\n        // TODO - should this implement some state, and be smart about whether\n        // stabilization is necessary or not? Would that be as simple as GET/POST?\n        // e.g. two gets in a row don't require a wait btwn.\n        //\n        // See https://code.google.com/p/selenium/wiki/JsonWireProtocol for\n        // descriptions of the paths.\n        // We shouldn't stabilize if we haven't loaded the page yet.\n        const parts = url.split('/');\n        if (parts.length < 4) {\n            return false;\n        }\n        const commandsToWaitFor = [\n            'executeScript', 'screenshot', 'source', 'title', 'element', 'elements', 'execute', 'keys',\n            'moveto', 'click', 'buttondown', 'buttonup', 'doubleclick', 'touch', 'get'\n        ];\n        if (commandsToWaitFor.indexOf(parts[3]) != -1) {\n            return true;\n        }\n        return false;\n    }\n    onCommand(command) {\n        if (this.logger) {\n            command.on('data', () => {\n                this.logger.logWebDriverCommand(command);\n            });\n        }\n        if (this.shouldStabilize(command)) {\n            const started = Date.now();\n            return this.sendRequestToStabilize(command).then(() => {\n                const ended = Date.now();\n                if (this.logger) {\n                    this.logger.logEvent('Waiting for Angular', command.sessionId, (ended - started));\n                }\n            });\n        }\n        return Promise.resolve(null);\n    }\n}\nexports.AngularWaitBarrier = AngularWaitBarrier;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}