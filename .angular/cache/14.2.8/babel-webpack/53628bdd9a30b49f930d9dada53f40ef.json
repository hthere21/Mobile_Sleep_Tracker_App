{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n/**\n * Describes an event listener registered on an {@linkplain EventEmitter}.\n */\n\nclass Listener {\n  /**\n   * @param {!Function} fn The actual listener function.\n   * @param {(Object|undefined)} scope The object in whose scope to invoke the\n   *     listener.\n   * @param {boolean} oneshot Whether this listener should only be used once.\n   */\n  constructor(fn, scope, oneshot) {\n    this.fn = fn;\n    this.scope = scope;\n    this.oneshot = oneshot;\n  }\n\n}\n/** @type {!WeakMap<!EventEmitter, !Map<string, !Set<!Listener>>>} */\n\n\nconst EVENTS = new WeakMap();\n/**\n * Object that can emit events for others to listen for.\n */\n\nclass EventEmitter {\n  /**\n   * Fires an event and calls all listeners.\n   * @param {string} type The type of event to emit.\n   * @param {...*} var_args Any arguments to pass to each listener.\n   */\n  emit(type, var_args) {\n    let events = EVENTS.get(this);\n\n    if (!events) {\n      return;\n    }\n\n    let args = Array.prototype.slice.call(arguments, 1);\n    let listeners = events.get(type);\n\n    if (listeners) {\n      for (let listener of listeners) {\n        listener.fn.apply(listener.scope, args);\n\n        if (listener.oneshot) {\n          listeners.delete(listener);\n        }\n      }\n    }\n  }\n  /**\n   * Returns a mutable list of listeners for a specific type of event.\n   * @param {string} type The type of event to retrieve the listeners for.\n   * @return {!Set<!Listener>} The registered listeners for the given event\n   *     type.\n   */\n\n\n  listeners(type) {\n    let events = EVENTS.get(this);\n\n    if (!events) {\n      events = new Map();\n      EVENTS.set(this, events);\n    }\n\n    let listeners = events.get(type);\n\n    if (!listeners) {\n      listeners = new Set();\n      events.set(type, listeners);\n    }\n\n    return listeners;\n  }\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @param {boolean=} opt_oneshot Whether the listener should b (e removed after\n   *    the first event is fired.\n   * @return {!EventEmitter} A self reference.\n   * @private\n   */\n\n\n  addListener_(type, fn, opt_self, opt_oneshot) {\n    let listeners = this.listeners(type);\n\n    for (let listener of listeners) {\n      if (listener.fn === fn) {\n        return this;\n      }\n    }\n\n    listeners.add(new Listener(fn, opt_self || undefined, !!opt_oneshot));\n    return this;\n  }\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  addListener(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, false);\n  }\n  /**\n   * Registers a one-time listener which will be called only the first time an\n   * event is emitted, after which it will be removed.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  once(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, true);\n  }\n  /**\n   * An alias for {@link #addListener() addListener()}.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  on(type, fn, opt_self) {\n    return this.addListener(type, fn, opt_self);\n  }\n  /**\n   * Removes a previously registered event listener.\n   * @param {string} type The type of event to unregister.\n   * @param {!Function} listenerFn The handler function to remove.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  removeListener(type, listenerFn) {\n    if (typeof type !== 'string' || typeof listenerFn !== 'function') {\n      throw TypeError('invalid args: expected (string, function), got (' + typeof type + ', ' + typeof listenerFn + ')');\n    }\n\n    let events = EVENTS.get(this);\n\n    if (!events) {\n      return this;\n    }\n\n    let listeners = events.get(type);\n\n    if (!listeners) {\n      return this;\n    }\n\n    let match;\n\n    for (let listener of listeners) {\n      if (listener.fn === listenerFn) {\n        match = listener;\n        break;\n      }\n    }\n\n    if (match) {\n      listeners.delete(match);\n\n      if (!listeners.size) {\n        events.delete(type);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Removes all listeners for a specific type of event. If no event is\n   * specified, all listeners across all types will be removed.\n   * @param {string=} opt_type The type of event to remove listeners from.\n   * @return {!EventEmitter} A self reference.\n   */\n\n\n  removeAllListeners(opt_type) {\n    let events = EVENTS.get(this);\n\n    if (events) {\n      if (typeof opt_type === 'string') {\n        events.delete(opt_type);\n      } else {\n        EVENTS.delete(this);\n      }\n    }\n\n    return this;\n  }\n\n} // PUBLIC API\n\n\nmodule.exports = {\n  EventEmitter: EventEmitter,\n  Listener: Listener\n};","map":{"version":3,"names":["Listener","constructor","fn","scope","oneshot","EVENTS","WeakMap","EventEmitter","emit","type","var_args","events","get","args","Array","prototype","slice","call","arguments","listeners","listener","apply","delete","Map","set","Set","addListener_","opt_self","opt_oneshot","add","undefined","addListener","once","on","removeListener","listenerFn","TypeError","match","size","removeAllListeners","opt_type","module","exports"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/selenium-webdriver/lib/events.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\n/**\n * Describes an event listener registered on an {@linkplain EventEmitter}.\n */\nclass Listener {\n  /**\n   * @param {!Function} fn The actual listener function.\n   * @param {(Object|undefined)} scope The object in whose scope to invoke the\n   *     listener.\n   * @param {boolean} oneshot Whether this listener should only be used once.\n   */\n  constructor(fn, scope, oneshot) {\n    this.fn = fn;\n    this.scope = scope;\n    this.oneshot = oneshot;\n  }\n}\n\n\n/** @type {!WeakMap<!EventEmitter, !Map<string, !Set<!Listener>>>} */\nconst EVENTS = new WeakMap;\n\n\n/**\n * Object that can emit events for others to listen for.\n */\nclass EventEmitter {\n  /**\n   * Fires an event and calls all listeners.\n   * @param {string} type The type of event to emit.\n   * @param {...*} var_args Any arguments to pass to each listener.\n   */\n  emit(type, var_args) {\n    let events = EVENTS.get(this);\n    if (!events) {\n      return;\n    }\n\n    let args = Array.prototype.slice.call(arguments, 1);\n\n    let listeners = events.get(type);\n    if (listeners) {\n      for (let listener of listeners) {\n        listener.fn.apply(listener.scope, args);\n        if (listener.oneshot) {\n          listeners.delete(listener);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns a mutable list of listeners for a specific type of event.\n   * @param {string} type The type of event to retrieve the listeners for.\n   * @return {!Set<!Listener>} The registered listeners for the given event\n   *     type.\n   */\n  listeners(type) {\n    let events = EVENTS.get(this);\n    if (!events) {\n      events = new Map;\n      EVENTS.set(this, events);\n    }\n\n    let listeners = events.get(type);\n    if (!listeners) {\n      listeners = new Set;\n      events.set(type, listeners);\n    }\n    return listeners;\n  }\n\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @param {boolean=} opt_oneshot Whether the listener should b (e removed after\n   *    the first event is fired.\n   * @return {!EventEmitter} A self reference.\n   * @private\n   */\n  addListener_(type, fn, opt_self, opt_oneshot) {\n    let listeners = this.listeners(type);\n    for (let listener of listeners) {\n      if (listener.fn === fn) {\n        return this;\n      }\n    }\n    listeners.add(new Listener(fn, opt_self || undefined, !!opt_oneshot));\n    return this;\n  }\n\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  addListener(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, false);\n  }\n\n  /**\n   * Registers a one-time listener which will be called only the first time an\n   * event is emitted, after which it will be removed.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  once(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, true);\n  }\n\n  /**\n   * An alias for {@link #addListener() addListener()}.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  on(type, fn, opt_self) {\n    return this.addListener(type, fn, opt_self);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   * @param {string} type The type of event to unregister.\n   * @param {!Function} listenerFn The handler function to remove.\n   * @return {!EventEmitter} A self reference.\n   */\n  removeListener(type, listenerFn) {\n    if (typeof type !== 'string' || typeof listenerFn !== 'function') {\n      throw TypeError('invalid args: expected (string, function), got ('\n          + (typeof type) + ', ' + (typeof listenerFn) + ')');\n    }\n\n    let events = EVENTS.get(this);\n    if (!events) {\n      return this;\n    }\n\n    let listeners = events.get(type);\n    if (!listeners) {\n      return this;\n    }\n\n    let match;\n    for (let listener of listeners) {\n      if (listener.fn === listenerFn) {\n        match = listener;\n        break;\n      }\n    }\n    if (match) {\n      listeners.delete(match);\n      if (!listeners.size) {\n        events.delete(type);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Removes all listeners for a specific type of event. If no event is\n   * specified, all listeners across all types will be removed.\n   * @param {string=} opt_type The type of event to remove listeners from.\n   * @return {!EventEmitter} A self reference.\n   */\n  removeAllListeners(opt_type) {\n    let events = EVENTS.get(this);\n    if (events) {\n      if (typeof opt_type === 'string') {\n        events.delete(opt_type);\n      } else {\n        EVENTS.delete(this);\n      }\n    }\n    return this;\n  }\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  EventEmitter: EventEmitter,\n  Listener: Listener\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}