{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nconst locators_1 = require(\"./locators\");\n\nconst logger_1 = require(\"./logger\");\n\nconst util_1 = require(\"./util\");\n\nlet clientSideScripts = require('./clientsidescripts');\n\nlet logger = new logger_1.Logger('element');\n\nclass WebdriverWebElement {}\n\nexports.WebdriverWebElement = WebdriverWebElement;\nlet WEB_ELEMENT_FUNCTIONS = ['click', 'sendKeys', 'getTagName', 'getCssValue', 'getAttribute', 'getText', 'getSize', 'getLocation', 'isEnabled', 'isSelected', 'submit', 'clear', 'isDisplayed', 'getId', 'takeScreenshot'];\n/**\n * ElementArrayFinder is used for operations on an array of elements (as opposed\n * to a single element).\n *\n * The ElementArrayFinder is used to set up a chain of conditions that identify\n * an array of elements. In particular, you can call all(locator) and\n * filter(filterFn) to return a new ElementArrayFinder modified by the\n * conditions, and you can call get(index) to return a single ElementFinder at\n * position 'index'.\n *\n * Similar to jquery, ElementArrayFinder will search all branches of the DOM\n * to find the elements that satisfy the conditions (i.e. all, filter, get).\n * However, an ElementArrayFinder will not actually retrieve the elements until\n * an action is called, which means it can be set up in helper files (i.e.\n * page objects) before the page is available, and reused as the page changes.\n *\n * You can treat an ElementArrayFinder as an array of WebElements for most\n * purposes, in particular, you may perform actions (i.e. click, getText) on\n * them as you would an array of WebElements. The action will apply to\n * every element identified by the ElementArrayFinder. ElementArrayFinder\n * extends Promise, and once an action is performed on an ElementArrayFinder,\n * the latest result can be accessed using then, and will be returned as an\n * array of the results; the array has length equal to the length of the\n * elements found by the ElementArrayFinder and each result represents the\n * result of performing the action on the element. Unlike a WebElement, an\n * ElementArrayFinder will wait for the angular app to settle before\n * performing finds or actions.\n *\n * @alias element.all(locator)\n * @view\n * <ul class=\"items\">\n *   <li>First</li>\n *   <li>Second</li>\n *   <li>Third</li>\n * </ul>\n *\n * @example\n * element.all(by.css('.items li')).then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * // Or using the shortcut $$() notation instead of element.all(by.css()):\n *\n * $$('.items li').then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * @constructor\n * @param {ProtractorBrowser} browser A browser instance.\n * @param {function(): Array.<webdriver.WebElement>} getWebElements A function\n *    that returns a list of the underlying Web Elements.\n * @param {webdriver.Locator} locator The most relevant locator. It is only\n *    used for error reporting and ElementArrayFinder.locator.\n * @param {Array.<webdriver.promise.Promise>} opt_actionResults An array\n *    of promises which will be retrieved with then. Resolves to the latest\n *    action result, or null if no action has been called.\n * @returns {ElementArrayFinder}\n */\n\nclass ElementArrayFinder extends WebdriverWebElement {\n  constructor(browser_, getWebElements = null, locator_, actionResults_ = null) {\n    super();\n    this.browser_ = browser_;\n    this.getWebElements = getWebElements;\n    this.locator_ = locator_;\n    this.actionResults_ = actionResults_; // TODO(juliemr): might it be easier to combine this with our docs and just\n    // wrap each one explicity with its own documentation?\n\n    WEB_ELEMENT_FUNCTIONS.forEach(fnName => {\n      this[fnName] = (...args) => {\n        let actionFn = webElem => {\n          return webElem[fnName].apply(webElem, args);\n        };\n\n        return this.applyAction_(actionFn);\n      };\n    });\n  }\n  /**\n   * Create a shallow copy of ElementArrayFinder.\n   *\n   * @returns {!ElementArrayFinder} A shallow copy of this.\n   */\n\n\n  clone() {\n    // A shallow copy is all we need since the underlying fields can never be\n    // modified. (Locator can be modified by the user, but that should\n    // rarely/never happen and it doesn't affect functionalities).\n    return new ElementArrayFinder(this.browser_, this.getWebElements, this.locator_, this.actionResults_);\n  }\n  /**\n   * Calls to ElementArrayFinder may be chained to find an array of elements\n   * using the current elements in this ElementArrayFinder as the starting\n   * point. This function returns a new ElementArrayFinder which would contain\n   * the children elements found (and could also be empty).\n   *\n   * @alias element.all(locator).all(locator)\n   * @view\n   * <div id='id1' class=\"parent\">\n   *   <ul>\n   *     <li class=\"foo\">1a</li>\n   *     <li class=\"baz\">1b</li>\n   *   </ul>\n   * </div>\n   * <div id='id2' class=\"parent\">\n   *   <ul>\n   *     <li class=\"foo\">2a</li>\n   *     <li class=\"bar\">2b</li>\n   *   </ul>\n   * </div>\n   *\n   * @example\n   * let foo = element.all(by.css('.parent')).all(by.css('.foo'));\n   * expect(foo.getText()).toEqual(['1a', '2a']);\n   * let baz = element.all(by.css('.parent')).all(by.css('.baz'));\n   * expect(baz.getText()).toEqual(['1b']);\n   * let nonexistent = element.all(by.css('.parent'))\n   *   .all(by.css('.NONEXISTENT'));\n   * expect(nonexistent.getText()).toEqual(['']);\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let foo = $$('.parent').$$('.foo');\n   * expect(foo.getText()).toEqual(['1a', '2a']);\n   * let baz = $$('.parent').$$('.baz');\n   * expect(baz.getText()).toEqual(['1b']);\n   * let nonexistent = $$('.parent').$$('.NONEXISTENT');\n   * expect(nonexistent.getText()).toEqual(['']);\n   *\n   * @param {webdriver.Locator} subLocator\n   * @returns {ElementArrayFinder}\n   */\n\n\n  all(locator) {\n    let ptor = this.browser_;\n\n    let getWebElements = () => {\n      if (this.getWebElements === null) {\n        // This is the first time we are looking for an element\n        return ptor.waitForAngular('Locator: ' + locator).then(() => {\n          if (locators_1.isProtractorLocator(locator)) {\n            return locator.findElementsOverride(ptor.driver, null, ptor.rootEl);\n          } else {\n            return ptor.driver.findElements(locator);\n          }\n        });\n      } else {\n        return this.getWebElements().then(parentWebElements => {\n          // For each parent web element, find their children and construct\n          // a list of Promise<List<child_web_element>>\n          let childrenPromiseList = parentWebElements.map(parentWebElement => {\n            return locators_1.isProtractorLocator(locator) ? locator.findElementsOverride(ptor.driver, parentWebElement, ptor.rootEl) : parentWebElement.findElements(locator);\n          }); // Resolve the list of Promise<List<child_web_elements>> and merge\n          // into a single list\n\n          return selenium_webdriver_1.promise.all(childrenPromiseList).then(resolved => {\n            return resolved.reduce((childrenList, resolvedE) => {\n              return childrenList.concat(resolvedE);\n            }, []);\n          });\n        });\n      }\n    };\n\n    return new ElementArrayFinder(this.browser_, getWebElements, locator);\n  }\n  /**\n   * Apply a filter function to each element within the ElementArrayFinder.\n   * Returns a new ElementArrayFinder with all elements that pass the filter\n   * function. The filter function receives the ElementFinder as the first\n   * argument and the index as a second arg. This does not actually retrieve\n   * the underlying list of elements, so it can be used in page objects.\n   *\n   * @alias element.all(locator).filter(filterFn)\n   * @view\n   * <ul class=\"items\">\n   *   <li class=\"one\">First</li>\n   *   <li class=\"two\">Second</li>\n   *   <li class=\"three\">Third</li>\n   * </ul>\n   *\n   * @example\n   * element.all(by.css('.items li')).filter(function(elem, index) {\n   *   return elem.getText().then(function(text) {\n   *     return text === 'Third';\n   *   });\n   * }).first().click();\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * $$('.items li').filter(function(elem, index) {\n   *   return elem.getText().then(function(text) {\n   *     return text === 'Third';\n   *   });\n   * }).first().click();\n   *\n   * @param {function(ElementFinder, number): webdriver.WebElement.Promise}\n   * filterFn\n   *     Filter function that will test if an element should be returned.\n   *     filterFn can either return a boolean or a promise that resolves to a\n   * boolean\n   * @returns {!ElementArrayFinder} A ElementArrayFinder that represents an\n   * array\n   *     of element that satisfy the filter function.\n   */\n\n\n  filter(filterFn) {\n    let getWebElements = () => {\n      return this.getWebElements().then(parentWebElements => {\n        let list = parentWebElements.map((parentWebElement, index) => {\n          let elementFinder = ElementFinder.fromWebElement_(this.browser_, parentWebElement, this.locator_);\n          return filterFn(elementFinder, index);\n        });\n        return selenium_webdriver_1.promise.all(list).then(resolvedList => {\n          return parentWebElements.filter((parentWebElement, index) => {\n            return resolvedList[index];\n          });\n        });\n      });\n    };\n\n    return new ElementArrayFinder(this.browser_, getWebElements, this.locator_);\n  }\n  /**\n   * Get an element within the ElementArrayFinder by index. The index starts at 0.\n   * Negative indices are wrapped (i.e. -i means ith element from last)\n   * This does not actually retrieve the underlying element.\n   *\n   * @alias element.all(locator).get(index)\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * let list = element.all(by.css('.items li'));\n   * expect(list.get(0).getText()).toBe('First');\n   * expect(list.get(1).getText()).toBe('Second');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let list = $$('.items li');\n   * expect(list.get(0).getText()).toBe('First');\n   * expect(list.get(1).getText()).toBe('Second');\n   *\n   * @param {number|webdriver.promise.Promise} index Element index.\n   * @returns {ElementFinder} finder representing element at the given index.\n   */\n\n\n  get(index) {\n    let getWebElements = () => {\n      return selenium_webdriver_1.promise.all([index, this.getWebElements()]).then(([i, parentWebElements]) => {\n        if (i < 0) {\n          i += parentWebElements.length;\n        }\n\n        if (i < 0 || i >= parentWebElements.length) {\n          throw new selenium_webdriver_1.error.NoSuchElementError('Index out of bound. Trying to access element at index: ' + index + ', but there are only ' + parentWebElements.length + ' elements that match ' + 'locator ' + this.locator_.toString());\n        }\n\n        return [parentWebElements[i]];\n      });\n    };\n\n    return new ElementArrayFinder(this.browser_, getWebElements, this.locator_).toElementFinder_();\n  }\n  /**\n   * Get the first matching element for the ElementArrayFinder. This does not\n   * actually retrieve the underlying element.\n   *\n   * @alias element.all(locator).first()\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * let first = element.all(by.css('.items li')).first();\n   * expect(first.getText()).toBe('First');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let first = $$('.items li').first();\n   * expect(first.getText()).toBe('First');\n   *\n   * @returns {ElementFinder} finder representing the first matching element\n   */\n\n\n  first() {\n    return this.get(0);\n  }\n\n  /**\n   * Get the last matching element for the ElementArrayFinder. This does not\n   * actually retrieve the underlying element.\n   *\n   * @alias element.all(locator).last()\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * let last = element.all(by.css('.items li')).last();\n   * expect(last.getText()).toBe('Third');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let last = $$('.items li').last();\n   * expect(last.getText()).toBe('Third');\n   *\n   * @returns {ElementFinder} finder representing the last matching element\n   */\n  last() {\n    return this.get(-1);\n  }\n  /**\n   * Shorthand function for finding arrays of elements by css.\n   * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n   *\n   * @alias $$(cssSelector)\n   * @view\n   * <div class=\"count\">\n   *   <span class=\"one\">First</span>\n   *   <span class=\"two\">Second</span>\n   * </div>\n   *\n   * @example\n   * // The following two blocks of code are equivalent.\n   * let list = element.all(by.css('.count span'));\n   * expect(list.count()).toBe(2);\n   * expect(list.get(0).getText()).toBe('First');\n   * expect(list.get(1).getText()).toBe('Second');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let list = $$('.count span');\n   * expect(list.count()).toBe(2);\n   * expect(list.get(0).getText()).toBe('First');\n   * expect(list.get(1).getText()).toBe('Second');\n   *\n   * @param {string} selector a css selector\n   * @returns {ElementArrayFinder} which identifies the\n   *     array of the located {@link webdriver.WebElement}s.\n   */\n\n\n  $$(selector) {\n    return this.all(selenium_webdriver_1.By.css(selector));\n  }\n  /**\n   * Returns an ElementFinder representation of ElementArrayFinder. It ensures\n   * that the ElementArrayFinder resolves to one and only one underlying\n   * element.\n   *\n   * @returns {ElementFinder} An ElementFinder representation\n   * @private\n   */\n\n\n  toElementFinder_() {\n    return new ElementFinder(this.browser_, this);\n  }\n  /**\n   * Count the number of elements represented by the ElementArrayFinder.\n   *\n   * @alias element.all(locator).count()\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * let list = element.all(by.css('.items li'));\n   * expect(list.count()).toBe(3);\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let list = $$('.items li');\n   * expect(list.count()).toBe(3);\n   *\n   * @returns {!webdriver.promise.Promise} A promise which resolves to the\n   *     number of elements matching the locator.\n   */\n\n\n  count() {\n    return this.getWebElements().then(arr => {\n      return arr.length;\n    }, err => {\n      if (err instanceof selenium_webdriver_1.error.NoSuchElementError) {\n        return 0;\n      } else {\n        throw err;\n      }\n    });\n  }\n  /**\n   * Returns true if there are any elements present that match the finder.\n   *\n   * @alias element.all(locator).isPresent()\n   *\n   * @example\n   * expect($('.item').isPresent()).toBeTruthy();\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  isPresent() {\n    return this.count().then(count => {\n      return count > 0;\n    });\n  }\n  /**\n   * Returns the most relevant locator.\n   *\n   * @example\n   * // returns by.css('#ID1')\n   * $('#ID1').locator();\n   *\n   * // returns by.css('#ID2')\n   * $('#ID1').$('#ID2').locator();\n   *\n   * // returns by.css('#ID1')\n   * $$('#ID1').filter(filterFn).get(0).click().locator();\n   *\n   * @returns {webdriver.Locator}\n   */\n\n\n  locator() {\n    return this.locator_;\n  }\n  /**\n   * Apply an action function to every element in the ElementArrayFinder,\n   * and return a new ElementArrayFinder that contains the results of the\n   * actions.\n   *\n   * @param {function(ElementFinder)} actionFn\n   *\n   * @returns {ElementArrayFinder}\n   * @private\n   */\n  // map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n\n\n  applyAction_(actionFn) {\n    let callerError = new Error();\n    let actionResults = this.getWebElements().then(arr => selenium_webdriver_1.promise.all(arr.map(actionFn))).then(value => {\n      return {\n        passed: true,\n        value: value\n      };\n    }, error => {\n      return {\n        passed: false,\n        value: error\n      };\n    });\n\n    let getWebElements = () => actionResults.then(() => this.getWebElements());\n\n    actionResults = actionResults.then(result => {\n      if (result.passed) {\n        return result.value;\n      } else {\n        let noSuchErr;\n\n        if (result.value instanceof Error) {\n          noSuchErr = result.value;\n          noSuchErr.stack = noSuchErr.stack + callerError.stack;\n        } else {\n          noSuchErr = new Error(result.value);\n          noSuchErr.stack = callerError.stack;\n        }\n\n        throw noSuchErr;\n      }\n    });\n    return new ElementArrayFinder(this.browser_, getWebElements, this.locator_, actionResults);\n  }\n  /**\n   * Represents the ElementArrayFinder as an array of ElementFinders.\n   *\n   * @returns {Array.<ElementFinder>} Return a promise, which resolves to a list\n   *     of ElementFinders specified by the locator.\n   */\n\n\n  asElementFinders_() {\n    return this.getWebElements().then(arr => {\n      return arr.map(webElem => {\n        return ElementFinder.fromWebElement_(this.browser_, webElem, this.locator_);\n      });\n    });\n  }\n  /**\n   * Retrieve the elements represented by the ElementArrayFinder. The input\n   * function is passed to the resulting promise, which resolves to an\n   * array of ElementFinders.\n   *\n   * @alias element.all(locator).then(thenFunction)\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * element.all(by.css('.items li')).then(function(arr) {\n   *   expect(arr.length).toEqual(3);\n   * });\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * $$('.items li').then(function(arr) {\n   *   expect(arr.length).toEqual(3);\n   * });\n   *\n   * @param {function(Array.<ElementFinder>)} fn\n   * @param {function(Error)} errorFn\n   *\n   * @returns {!webdriver.promise.Promise} A promise which will resolve to\n   *     an array of ElementFinders represented by the ElementArrayFinder.\n   */\n\n\n  then(fn, errorFn) {\n    if (this.actionResults_) {\n      return this.actionResults_.then(fn, errorFn);\n    } else {\n      return this.asElementFinders_().then(fn, errorFn);\n    }\n  }\n  /**\n   * Calls the input function on each ElementFinder represented by the\n   * ElementArrayFinder.\n   *\n   * @alias element.all(locator).each(eachFunction)\n   * @view\n   * <ul class=\"items\">\n   *   <li>First</li>\n   *   <li>Second</li>\n   *   <li>Third</li>\n   * </ul>\n   *\n   * @example\n   * element.all(by.css('.items li')).each(function(element, index) {\n   *   // Will print 0 First, 1 Second, 2 Third.\n   *   element.getText().then(function (text) {\n   *     console.log(index, text);\n   *   });\n   * });\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * $$('.items li').each(function(element, index) {\n   *   // Will print 0 First, 1 Second, 2 Third.\n   *   element.getText().then(function (text) {\n   *     console.log(index, text);\n   *   });\n   * });\n   *\n   * @param {function(ElementFinder)} fn Input function\n   *\n   * @returns {!webdriver.promise.Promise} A promise that will resolve when the\n   *     function has been called on all the ElementFinders. The promise will\n   *     resolve to null.\n   */\n\n\n  each(fn) {\n    return this.map(fn).then(() => {\n      return null;\n    });\n  }\n  /**\n   * Apply a map function to each element within the ElementArrayFinder. The\n   * callback receives the ElementFinder as the first argument and the index as\n   * a second arg.\n   *\n   * @alias element.all(locator).map(mapFunction)\n   * @view\n   * <ul class=\"items\">\n   *   <li class=\"one\">First</li>\n   *   <li class=\"two\">Second</li>\n   *   <li class=\"three\">Third</li>\n   * </ul>\n   *\n   * @example\n   * let items = element.all(by.css('.items li')).map(function(elm, index) {\n   *   return {\n   *     index: index,\n   *     text: elm.getText(),\n   *     class: elm.getAttribute('class')\n   *   };\n   * });\n   * expect(items).toEqual([\n   *   {index: 0, text: 'First', class: 'one'},\n   *   {index: 1, text: 'Second', class: 'two'},\n   *   {index: 2, text: 'Third', class: 'three'}\n   * ]);\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let items = $$('.items li').map(function(elm, index) {\n   *   return {\n   *     index: index,\n   *     text: elm.getText(),\n   *     class: elm.getAttribute('class')\n   *   };\n   * });\n   * expect(items).toEqual([\n   *   {index: 0, text: 'First', class: 'one'},\n   *   {index: 1, text: 'Second', class: 'two'},\n   *   {index: 2, text: 'Third', class: 'three'}\n   * ]);\n   *\n   * @param {function(ElementFinder, number)} mapFn Map function that\n   *     will be applied to each element.\n   * @returns {!webdriver.promise.Promise} A promise that resolves to an array\n   *     of values returned by the map function.\n   */\n\n\n  map(mapFn) {\n    return this.asElementFinders_().then(arr => {\n      let list = arr.map((elementFinder, index) => {\n        let mapResult = mapFn(elementFinder, index); // All nested arrays and objects will also be fully resolved.\n\n        return selenium_webdriver_1.promise.fullyResolved(mapResult);\n      });\n      return selenium_webdriver_1.promise.all(list);\n    });\n  }\n\n  /**\n   * Apply a reduce function against an accumulator and every element found\n   * using the locator (from left-to-right). The reduce function has to reduce\n   * every element into a single value (the accumulator). Returns promise of\n   * the accumulator. The reduce function receives the accumulator, current\n   * ElementFinder, the index, and the entire array of ElementFinders,\n   * respectively.\n   *\n   * @alias element.all(locator).reduce(reduceFn)\n   * @view\n   * <ul class=\"items\">\n   *   <li class=\"one\">First</li>\n   *   <li class=\"two\">Second</li>\n   *   <li class=\"three\">Third</li>\n   * </ul>\n   *\n   * @example\n   * let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n   *   return elem.getText().then(function(text) {\n   *     return acc + text + ' ';\n   *   });\n   * }, '');\n   *\n   * expect(value).toEqual('First Second Third ');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let value = $$('.items li').reduce(function(acc, elem) {\n   *   return elem.getText().then(function(text) {\n   *     return acc + text + ' ';\n   *   });\n   * }, '');\n   *\n   * expect(value).toEqual('First Second Third ');\n   *\n   * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n   *     reduceFn Reduce function that reduces every element into a single\n   * value.\n   * @param {*} initialValue Initial value of the accumulator.\n   * @returns {!webdriver.promise.Promise} A promise that resolves to the final\n   *     value of the accumulator.\n   */\n  reduce(reduceFn, initialValue) {\n    let valuePromise = selenium_webdriver_1.promise.when(initialValue);\n    return this.asElementFinders_().then(arr => {\n      return arr.reduce((valuePromise, elementFinder, index) => {\n        return valuePromise.then(value => {\n          return reduceFn(value, elementFinder, index, arr);\n        });\n      }, valuePromise);\n    });\n  }\n  /**\n   * Evaluates the input as if it were on the scope of the current underlying\n   * elements.\n   *\n   * @view\n   * <span class=\"foo\">{{letiableInScope}}</span>\n   *\n   * @example\n   * let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n   *\n   * // Or using the shortcut $$() notation instead of element.all(by.css()):\n   *\n   * let value = $$('.foo').evaluate('letiableInScope');\n   *\n   * @param {string} expression\n   *\n   * @returns {ElementArrayFinder} which resolves to the\n   *     evaluated expression for each underlying element.\n   *     The result will be resolved as in\n   *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n   *     be resolved as is, functions will be converted to string, and elements\n   *     will be returned as a WebElement.\n   */\n\n\n  evaluate(expression) {\n    let evaluationFn = webElem => {\n      return webElem.getDriver().executeScript(clientSideScripts.evaluate, webElem, expression);\n    };\n\n    return this.applyAction_(evaluationFn);\n  }\n  /**\n   * Determine if animation is allowed on the current underlying elements.\n   * @param {string} value\n   *\n   * @example\n   * // Turns off ng-animate animations for all elements in the <body>\n   * element(by.css('body')).allowAnimations(false);\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * $('body').allowAnimations(false);\n   *\n   * @returns {ElementArrayFinder} which resolves to whether animation is\n   * allowed.\n   */\n\n\n  allowAnimations(value) {\n    let allowAnimationsTestFn = webElem => {\n      return webElem.getDriver().executeScript(clientSideScripts.allowAnimations, webElem, value);\n    };\n\n    return this.applyAction_(allowAnimationsTestFn);\n  }\n\n}\n\nexports.ElementArrayFinder = ElementArrayFinder;\n/**\n * The ElementFinder simply represents a single element of an\n * ElementArrayFinder (and is more like a convenience object). As a result,\n * anything that can be done with an ElementFinder, can also be done using\n * an ElementArrayFinder.\n *\n * The ElementFinder can be treated as a WebElement for most purposes, in\n * particular, you may perform actions (i.e. click, getText) on them as you\n * would a WebElement. Once an action is performed on an ElementFinder, the\n * latest result from the chain can be accessed using the then method.\n * Unlike a WebElement, an ElementFinder will wait for angular to settle before\n * performing finds or actions.\n *\n * ElementFinder can be used to build a chain of locators that is used to find\n * an element. An ElementFinder does not actually attempt to find the element\n * until an action is called, which means they can be set up in helper files\n * before the page is available.\n *\n * @alias element(locator)\n * @view\n * <span>{{person.name}}</span>\n * <span ng-bind=\"person.email\"></span>\n * <input type=\"text\" ng-model=\"person.name\"/>\n *\n * @example\n * // Find element with {{scopelet}} syntax.\n * element(by.binding('person.name')).getText().then(function(name) {\n *   expect(name).toBe('Foo');\n * });\n *\n * // Find element with ng-bind=\"scopelet\" syntax.\n * expect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n *\n * // Find by model.\n * let input = element(by.model('person.name'));\n * input.sendKeys('123');\n * expect(input.getAttribute('value')).toBe('Foo123');\n *\n * @constructor\n * @extends {webdriver.WebElement}\n * @param {ProtractorBrowser} browser_ A browser instance.\n * @param {ElementArrayFinder} elementArrayFinder The ElementArrayFinder\n *     that this is branched from.\n * @returns {ElementFinder}\n */\n\nclass ElementFinder extends WebdriverWebElement {\n  constructor(browser_, elementArrayFinder) {\n    super();\n    this.browser_ = browser_;\n    this.then = null;\n\n    if (!elementArrayFinder) {\n      throw new Error('BUG: elementArrayFinder cannot be empty');\n    }\n\n    this.parentElementArrayFinder = elementArrayFinder; // Only have a `then` method if the parent element array finder\n    // has action results.\n\n    if (this.parentElementArrayFinder.actionResults_) {\n      // Access the underlying actionResult of ElementFinder.\n      this.then = (fn, errorFn) => {\n        return this.elementArrayFinder_.then(actionResults => {\n          if (!fn) {\n            return actionResults[0];\n          }\n\n          return fn(actionResults[0]);\n        }, errorFn);\n      };\n    } // This filter verifies that there is only 1 element returned by the\n    // elementArrayFinder. It will warn if there are more than 1 element and\n    // throw an error if there are no elements.\n\n\n    let getWebElements = () => {\n      return elementArrayFinder.getWebElements().then(webElements => {\n        if (webElements.length === 0) {\n          throw new selenium_webdriver_1.error.NoSuchElementError('No element found using locator: ' + elementArrayFinder.locator().toString());\n        } else {\n          if (webElements.length > 1) {\n            logger.warn('more than one element found for locator ' + elementArrayFinder.locator().toString() + ' - the first result will be used');\n          }\n\n          return [webElements[0]];\n        }\n      });\n    }; // Store a copy of the underlying elementArrayFinder, but with the more\n    // restrictive getWebElements (which checks that there is only 1 element).\n\n\n    this.elementArrayFinder_ = new ElementArrayFinder(this.browser_, getWebElements, elementArrayFinder.locator(), elementArrayFinder.actionResults_);\n    WEB_ELEMENT_FUNCTIONS.forEach(fnName => {\n      this[fnName] = (...args) => {\n        return this.elementArrayFinder_[fnName].apply(this.elementArrayFinder_, args).toElementFinder_();\n      };\n    });\n  }\n\n  static fromWebElement_(browser, webElem, locator) {\n    let getWebElements = () => {\n      return selenium_webdriver_1.promise.when([webElem]);\n    };\n\n    return new ElementArrayFinder(browser, getWebElements, locator).toElementFinder_();\n  }\n  /**\n   * Create a shallow copy of ElementFinder.\n   *\n   * @returns {!ElementFinder} A shallow copy of this.\n   */\n\n\n  clone() {\n    // A shallow copy is all we need since the underlying fields can never be\n    // modified\n    return new ElementFinder(this.browser_, this.parentElementArrayFinder);\n  }\n  /**\n   * @see ElementArrayFinder.prototype.locator\n   *\n   * @returns {webdriver.Locator}\n   */\n\n\n  locator() {\n    return this.elementArrayFinder_.locator();\n  }\n  /**\n   * Returns the WebElement represented by this ElementFinder.\n   * Throws the WebDriver error if the element doesn't exist.\n   *\n   * @alias element(locator).getWebElement()\n   * @view\n   * <div class=\"parent\">\n   *   some text\n   * </div>\n   *\n   * @example\n   * // The following four expressions are equivalent.\n   * $('.parent').getWebElement();\n   * element(by.css('.parent')).getWebElement();\n   * browser.driver.findElement(by.css('.parent'));\n   * browser.findElement(by.css('.parent'));\n   *\n   * @returns {webdriver.WebElementPromise}\n   */\n\n\n  getWebElement() {\n    let id = this.elementArrayFinder_.getWebElements().then(parentWebElements => {\n      return parentWebElements[0];\n    });\n    return new selenium_webdriver_1.WebElementPromise(this.browser_.driver, id);\n  }\n  /**\n   * Calls to {@code all} may be chained to find an array of elements within a\n   * parent.\n   *\n   * @alias element(locator).all(locator)\n   * @view\n   * <div class=\"parent\">\n   *   <ul>\n   *     <li class=\"one\">First</li>\n   *     <li class=\"two\">Second</li>\n   *     <li class=\"three\">Third</li>\n   *   </ul>\n   * </div>\n   *\n   * @example\n   * let items = element(by.css('.parent')).all(by.tagName('li'));\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * let items = $('.parent').all(by.tagName('li'));\n   *\n   * @param {webdriver.Locator} subLocator\n   * @returns {ElementArrayFinder}\n   */\n\n\n  all(subLocator) {\n    return this.elementArrayFinder_.all(subLocator);\n  }\n  /**\n   * Calls to {@code element} may be chained to find elements within a parent.\n   *\n   * @alias element(locator).element(locator)\n   * @view\n   * <div class=\"parent\">\n   *   <div class=\"child\">\n   *     Child text\n   *     <div>{{person.phone}}</div>\n   *   </div>\n   * </div>\n   *\n   * @example\n   * // Chain 2 element calls.\n   * let child = element(by.css('.parent')).\n   *     element(by.css('.child'));\n   * expect(child.getText()).toBe('Child text\\n555-123-4567');\n   *\n   * // Chain 3 element calls.\n   * let triple = element(by.css('.parent')).\n   *     element(by.css('.child')).\n   *     element(by.binding('person.phone'));\n   * expect(triple.getText()).toBe('555-123-4567');\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * // Chain 2 element calls.\n   * let child = $('.parent').$('.child');\n   * expect(child.getText()).toBe('Child text\\n555-123-4567');\n   *\n   * // Chain 3 element calls.\n   * let triple = $('.parent').$('.child').\n   *     element(by.binding('person.phone'));\n   * expect(triple.getText()).toBe('555-123-4567');\n   *\n   * @param {webdriver.Locator} subLocator\n   * @returns {ElementFinder}\n   */\n\n\n  element(subLocator) {\n    return this.all(subLocator).toElementFinder_();\n  }\n  /**\n   * Calls to {@code $$} may be chained to find an array of elements within a\n   * parent.\n   *\n   * @alias element(locator).all(selector)\n   * @view\n   * <div class=\"parent\">\n   *   <ul>\n   *     <li class=\"one\">First</li>\n   *     <li class=\"two\">Second</li>\n   *     <li class=\"three\">Third</li>\n   *   </ul>\n   * </div>\n   *\n   * @example\n   * let items = element(by.css('.parent')).$$('li');\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * let items = $('.parent').$$('li');\n   *\n   * @param {string} selector a css selector\n   * @returns {ElementArrayFinder}\n   */\n\n\n  $$(selector) {\n    return this.all(selenium_webdriver_1.By.css(selector));\n  }\n  /**\n   * Calls to {@code $} may be chained to find elements within a parent.\n   *\n   * @alias element(locator).$(selector)\n   * @view\n   * <div class=\"parent\">\n   *   <div class=\"child\">\n   *     Child text\n   *     <div>{{person.phone}}</div>\n   *   </div>\n   * </div>\n   *\n   * @example\n   * // Chain 2 element calls.\n   * let child = element(by.css('.parent')).\n   *     $('.child');\n   * expect(child.getText()).toBe('Child text\\n555-123-4567');\n   *\n   * // Chain 3 element calls.\n   * let triple = element(by.css('.parent')).\n   *     $('.child').\n   *     element(by.binding('person.phone'));\n   * expect(triple.getText()).toBe('555-123-4567');\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * // Chain 2 element calls.\n   * let child = $('.parent').$('.child');\n   * expect(child.getText()).toBe('Child text\\n555-123-4567');\n   *\n   * // Chain 3 element calls.\n   * let triple = $('.parent').$('.child').\n   *     element(by.binding('person.phone'));\n   * expect(triple.getText()).toBe('555-123-4567');\n   *\n   * @param {string} selector A css selector\n   * @returns {ElementFinder}\n   */\n\n\n  $(selector) {\n    return this.element(selenium_webdriver_1.By.css(selector));\n  }\n  /**\n   * Determine whether the element is present on the page.\n   *\n   * @view\n   * <span>{{person.name}}</span>\n   *\n   * @example\n   * // Element exists.\n   * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n   *\n   * // Element not present.\n   * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n   *\n   * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n   *     the element is present on the page.\n   */\n\n\n  isPresent() {\n    return this.parentElementArrayFinder.getWebElements().then(arr => {\n      if (arr.length === 0) {\n        return false;\n      }\n\n      return arr[0].isEnabled().then(() => {\n        return true; // is present, whether it is enabled or not\n      }, util_1.falseIfMissing);\n    }, util_1.falseIfMissing);\n  }\n  /**\n   * Same as ElementFinder.isPresent(), except this checks whether the element\n   * identified by the subLocator is present, rather than the current element\n   * finder, i.e.: `element(by.css('#abc')).element(by.css('#def')).isPresent()`\n   * is identical to `element(by.css('#abc')).isElementPresent(by.css('#def'))`.\n   *\n   * // Or using the shortcut $() notation instead of element(by.css()):\n   *\n   * `$('#abc').$('#def').isPresent()` is identical to\n   * `$('#abc').isElementPresent($('#def'))`.\n   *\n   * @see ElementFinder.isPresent\n   *\n   * @param {webdriver.Locator} subLocator Locator for element to look for.\n   * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n   *     the subelement is present on the page.\n   */\n\n\n  isElementPresent(subLocator) {\n    if (!subLocator) {\n      throw new Error('SubLocator is not supplied as a parameter to ' + '`isElementPresent(subLocator)`. You are probably looking for the ' + 'function `isPresent()`.');\n    }\n\n    return this.element(subLocator).isPresent();\n  }\n  /**\n   * Evaluates the input as if it were on the scope of the current element.\n   * @see ElementArrayFinder.prototype.evaluate\n   *\n   * @view\n   * <span id=\"foo\">{{letiableInScope}}</span>\n   *\n   * @example\n   * let value = element(by.id('foo')).evaluate('letiableInScope');\n   *\n   * @param {string} expression\n   *\n   * @returns {ElementFinder} which resolves to the evaluated expression.\n   */\n\n\n  evaluate(expression) {\n    return this.elementArrayFinder_.evaluate(expression).toElementFinder_();\n  }\n  /**\n   * @see ElementArrayFinder.prototype.allowAnimations.\n   * @param {string} value\n   *\n   * @returns {ElementFinder} which resolves to whether animation is allowed.\n   */\n\n\n  allowAnimations(value) {\n    return this.elementArrayFinder_.allowAnimations(value).toElementFinder_();\n  }\n  /**\n   * Compares an element to this one for equality.\n   *\n   * @param {!ElementFinder|!webdriver.WebElement} The element to compare to.\n   *\n   * @returns {!webdriver.promise.Promise.<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n\n\n  equals(element) {\n    return selenium_webdriver_1.WebElement.equals(this.getWebElement(), element.getWebElement ? element.getWebElement() : element);\n  }\n\n}\n\nexports.ElementFinder = ElementFinder;\n/**\n * Shortcut for querying the document directly with css.\n * `element(by.css('.abc'))` is equivalent to `$('.abc')`\n *\n * @alias $(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * let item = $('.count .two');\n * expect(item.getText()).toBe('Second');\n *\n * @param {string} selector A css selector\n * @returns {ElementFinder} which identifies the located\n *     {@link webdriver.WebElement}\n */\n\nexports.build$ = (element, by) => {\n  return selector => {\n    return element(by.css(selector));\n  };\n};\n/**\n * Shortcut for querying the document directly with css.\n * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n *\n * @alias $$(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * // The following protractor expressions are equivalent.\n * let list = element.all(by.css('.count span'));\n * expect(list.count()).toBe(2);\n *\n * list = $$('.count span');\n * expect(list.count()).toBe(2);\n * expect(list.get(0).getText()).toBe('First');\n * expect(list.get(1).getText()).toBe('Second');\n *\n * @param {string} selector a css selector\n * @returns {ElementArrayFinder} which identifies the\n *     array of the located {@link webdriver.WebElement}s.\n */\n\n\nexports.build$$ = (element, by) => {\n  return selector => {\n    return element.all(by.css(selector));\n  };\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","selenium_webdriver_1","require","locators_1","logger_1","util_1","clientSideScripts","logger","Logger","WebdriverWebElement","WEB_ELEMENT_FUNCTIONS","ElementArrayFinder","constructor","browser_","getWebElements","locator_","actionResults_","forEach","fnName","args","actionFn","webElem","apply","applyAction_","clone","all","locator","ptor","waitForAngular","then","isProtractorLocator","findElementsOverride","driver","rootEl","findElements","parentWebElements","childrenPromiseList","map","parentWebElement","promise","resolved","reduce","childrenList","resolvedE","concat","filter","filterFn","list","index","elementFinder","ElementFinder","fromWebElement_","resolvedList","get","i","length","error","NoSuchElementError","toString","toElementFinder_","first","last","$$","selector","By","css","count","arr","err","isPresent","callerError","Error","actionResults","passed","result","noSuchErr","stack","asElementFinders_","fn","errorFn","each","mapFn","mapResult","fullyResolved","reduceFn","initialValue","valuePromise","when","evaluate","expression","evaluationFn","getDriver","executeScript","allowAnimations","allowAnimationsTestFn","elementArrayFinder","parentElementArrayFinder","elementArrayFinder_","webElements","warn","browser","getWebElement","id","WebElementPromise","subLocator","element","$","isEnabled","falseIfMissing","isElementPresent","equals","WebElement","build$","by","build$$"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/protractor/built/element.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\nconst locators_1 = require(\"./locators\");\nconst logger_1 = require(\"./logger\");\nconst util_1 = require(\"./util\");\nlet clientSideScripts = require('./clientsidescripts');\nlet logger = new logger_1.Logger('element');\nclass WebdriverWebElement {\n}\nexports.WebdriverWebElement = WebdriverWebElement;\nlet WEB_ELEMENT_FUNCTIONS = [\n    'click', 'sendKeys', 'getTagName', 'getCssValue', 'getAttribute', 'getText', 'getSize',\n    'getLocation', 'isEnabled', 'isSelected', 'submit', 'clear', 'isDisplayed', 'getId',\n    'takeScreenshot'\n];\n/**\n * ElementArrayFinder is used for operations on an array of elements (as opposed\n * to a single element).\n *\n * The ElementArrayFinder is used to set up a chain of conditions that identify\n * an array of elements. In particular, you can call all(locator) and\n * filter(filterFn) to return a new ElementArrayFinder modified by the\n * conditions, and you can call get(index) to return a single ElementFinder at\n * position 'index'.\n *\n * Similar to jquery, ElementArrayFinder will search all branches of the DOM\n * to find the elements that satisfy the conditions (i.e. all, filter, get).\n * However, an ElementArrayFinder will not actually retrieve the elements until\n * an action is called, which means it can be set up in helper files (i.e.\n * page objects) before the page is available, and reused as the page changes.\n *\n * You can treat an ElementArrayFinder as an array of WebElements for most\n * purposes, in particular, you may perform actions (i.e. click, getText) on\n * them as you would an array of WebElements. The action will apply to\n * every element identified by the ElementArrayFinder. ElementArrayFinder\n * extends Promise, and once an action is performed on an ElementArrayFinder,\n * the latest result can be accessed using then, and will be returned as an\n * array of the results; the array has length equal to the length of the\n * elements found by the ElementArrayFinder and each result represents the\n * result of performing the action on the element. Unlike a WebElement, an\n * ElementArrayFinder will wait for the angular app to settle before\n * performing finds or actions.\n *\n * @alias element.all(locator)\n * @view\n * <ul class=\"items\">\n *   <li>First</li>\n *   <li>Second</li>\n *   <li>Third</li>\n * </ul>\n *\n * @example\n * element.all(by.css('.items li')).then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * // Or using the shortcut $$() notation instead of element.all(by.css()):\n *\n * $$('.items li').then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * @constructor\n * @param {ProtractorBrowser} browser A browser instance.\n * @param {function(): Array.<webdriver.WebElement>} getWebElements A function\n *    that returns a list of the underlying Web Elements.\n * @param {webdriver.Locator} locator The most relevant locator. It is only\n *    used for error reporting and ElementArrayFinder.locator.\n * @param {Array.<webdriver.promise.Promise>} opt_actionResults An array\n *    of promises which will be retrieved with then. Resolves to the latest\n *    action result, or null if no action has been called.\n * @returns {ElementArrayFinder}\n */\nclass ElementArrayFinder extends WebdriverWebElement {\n    constructor(browser_, getWebElements = null, locator_, actionResults_ = null) {\n        super();\n        this.browser_ = browser_;\n        this.getWebElements = getWebElements;\n        this.locator_ = locator_;\n        this.actionResults_ = actionResults_;\n        // TODO(juliemr): might it be easier to combine this with our docs and just\n        // wrap each one explicity with its own documentation?\n        WEB_ELEMENT_FUNCTIONS.forEach((fnName) => {\n            this[fnName] = (...args) => {\n                let actionFn = (webElem) => {\n                    return webElem[fnName].apply(webElem, args);\n                };\n                return this.applyAction_(actionFn);\n            };\n        });\n    }\n    /**\n     * Create a shallow copy of ElementArrayFinder.\n     *\n     * @returns {!ElementArrayFinder} A shallow copy of this.\n     */\n    clone() {\n        // A shallow copy is all we need since the underlying fields can never be\n        // modified. (Locator can be modified by the user, but that should\n        // rarely/never happen and it doesn't affect functionalities).\n        return new ElementArrayFinder(this.browser_, this.getWebElements, this.locator_, this.actionResults_);\n    }\n    /**\n     * Calls to ElementArrayFinder may be chained to find an array of elements\n     * using the current elements in this ElementArrayFinder as the starting\n     * point. This function returns a new ElementArrayFinder which would contain\n     * the children elements found (and could also be empty).\n     *\n     * @alias element.all(locator).all(locator)\n     * @view\n     * <div id='id1' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">1a</li>\n     *     <li class=\"baz\">1b</li>\n     *   </ul>\n     * </div>\n     * <div id='id2' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">2a</li>\n     *     <li class=\"bar\">2b</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let foo = element.all(by.css('.parent')).all(by.css('.foo'));\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = element.all(by.css('.parent')).all(by.css('.baz'));\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = element.all(by.css('.parent'))\n     *   .all(by.css('.NONEXISTENT'));\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let foo = $$('.parent').$$('.foo');\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = $$('.parent').$$('.baz');\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = $$('.parent').$$('.NONEXISTENT');\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n    all(locator) {\n        let ptor = this.browser_;\n        let getWebElements = () => {\n            if (this.getWebElements === null) {\n                // This is the first time we are looking for an element\n                return ptor.waitForAngular('Locator: ' + locator)\n                    .then(() => {\n                    if (locators_1.isProtractorLocator(locator)) {\n                        return locator.findElementsOverride(ptor.driver, null, ptor.rootEl);\n                    }\n                    else {\n                        return ptor.driver.findElements(locator);\n                    }\n                });\n            }\n            else {\n                return this.getWebElements().then((parentWebElements) => {\n                    // For each parent web element, find their children and construct\n                    // a list of Promise<List<child_web_element>>\n                    let childrenPromiseList = parentWebElements.map((parentWebElement) => {\n                        return locators_1.isProtractorLocator(locator) ?\n                            locator.findElementsOverride(ptor.driver, parentWebElement, ptor.rootEl) :\n                            parentWebElement.findElements(locator);\n                    });\n                    // Resolve the list of Promise<List<child_web_elements>> and merge\n                    // into a single list\n                    return selenium_webdriver_1.promise.all(childrenPromiseList)\n                        .then((resolved) => {\n                        return resolved.reduce((childrenList, resolvedE) => {\n                            return childrenList.concat(resolvedE);\n                        }, []);\n                    });\n                });\n            }\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, locator);\n    }\n    /**\n     * Apply a filter function to each element within the ElementArrayFinder.\n     * Returns a new ElementArrayFinder with all elements that pass the filter\n     * function. The filter function receives the ElementFinder as the first\n     * argument and the index as a second arg. This does not actually retrieve\n     * the underlying list of elements, so it can be used in page objects.\n     *\n     * @alias element.all(locator).filter(filterFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * @param {function(ElementFinder, number): webdriver.WebElement.Promise}\n     * filterFn\n     *     Filter function that will test if an element should be returned.\n     *     filterFn can either return a boolean or a promise that resolves to a\n     * boolean\n     * @returns {!ElementArrayFinder} A ElementArrayFinder that represents an\n     * array\n     *     of element that satisfy the filter function.\n     */\n    filter(filterFn) {\n        let getWebElements = () => {\n            return this.getWebElements().then((parentWebElements) => {\n                let list = parentWebElements.map((parentWebElement, index) => {\n                    let elementFinder = ElementFinder.fromWebElement_(this.browser_, parentWebElement, this.locator_);\n                    return filterFn(elementFinder, index);\n                });\n                return selenium_webdriver_1.promise.all(list).then((resolvedList) => {\n                    return parentWebElements.filter((parentWebElement, index) => {\n                        return resolvedList[index];\n                    });\n                });\n            });\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_);\n    }\n    /**\n     * Get an element within the ElementArrayFinder by index. The index starts at 0.\n     * Negative indices are wrapped (i.e. -i means ith element from last)\n     * This does not actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).get(index)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {number|webdriver.promise.Promise} index Element index.\n     * @returns {ElementFinder} finder representing element at the given index.\n     */\n    get(index) {\n        let getWebElements = () => {\n            return selenium_webdriver_1.promise.all([index, this.getWebElements()]).then(([i, parentWebElements]) => {\n                if (i < 0) {\n                    i += parentWebElements.length;\n                }\n                if (i < 0 || i >= parentWebElements.length) {\n                    throw new selenium_webdriver_1.error.NoSuchElementError('Index out of bound. Trying to access element at index: ' + index +\n                        ', but there are only ' + parentWebElements.length + ' elements that match ' +\n                        'locator ' + this.locator_.toString());\n                }\n                return [parentWebElements[i]];\n            });\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_).toElementFinder_();\n    }\n    /**\n     * Get the first matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).first()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let first = element.all(by.css('.items li')).first();\n     * expect(first.getText()).toBe('First');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let first = $$('.items li').first();\n     * expect(first.getText()).toBe('First');\n     *\n     * @returns {ElementFinder} finder representing the first matching element\n     */\n    first() {\n        return this.get(0);\n    }\n    ;\n    /**\n     * Get the last matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).last()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let last = element.all(by.css('.items li')).last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let last = $$('.items li').last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * @returns {ElementFinder} finder representing the last matching element\n     */\n    last() {\n        return this.get(-1);\n    }\n    /**\n     * Shorthand function for finding arrays of elements by css.\n     * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n     *\n     * @alias $$(cssSelector)\n     * @view\n     * <div class=\"count\">\n     *   <span class=\"one\">First</span>\n     *   <span class=\"two\">Second</span>\n     * </div>\n     *\n     * @example\n     * // The following two blocks of code are equivalent.\n     * let list = element.all(by.css('.count span'));\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.count span');\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder} which identifies the\n     *     array of the located {@link webdriver.WebElement}s.\n     */\n    $$(selector) {\n        return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Returns an ElementFinder representation of ElementArrayFinder. It ensures\n     * that the ElementArrayFinder resolves to one and only one underlying\n     * element.\n     *\n     * @returns {ElementFinder} An ElementFinder representation\n     * @private\n     */\n    toElementFinder_() {\n        return new ElementFinder(this.browser_, this);\n    }\n    /**\n     * Count the number of elements represented by the ElementArrayFinder.\n     *\n     * @alias element.all(locator).count()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.count()).toBe(3);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.count()).toBe(3);\n     *\n     * @returns {!webdriver.promise.Promise} A promise which resolves to the\n     *     number of elements matching the locator.\n     */\n    count() {\n        return this.getWebElements().then((arr) => {\n            return arr.length;\n        }, (err) => {\n            if (err instanceof selenium_webdriver_1.error.NoSuchElementError) {\n                return 0;\n            }\n            else {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Returns true if there are any elements present that match the finder.\n     *\n     * @alias element.all(locator).isPresent()\n     *\n     * @example\n     * expect($('.item').isPresent()).toBeTruthy();\n     *\n     * @returns {Promise<boolean>}\n     */\n    isPresent() {\n        return this.count().then((count) => {\n            return count > 0;\n        });\n    }\n    /**\n     * Returns the most relevant locator.\n     *\n     * @example\n     * // returns by.css('#ID1')\n     * $('#ID1').locator();\n     *\n     * // returns by.css('#ID2')\n     * $('#ID1').$('#ID2').locator();\n     *\n     * // returns by.css('#ID1')\n     * $$('#ID1').filter(filterFn).get(0).click().locator();\n     *\n     * @returns {webdriver.Locator}\n     */\n    locator() {\n        return this.locator_;\n    }\n    /**\n     * Apply an action function to every element in the ElementArrayFinder,\n     * and return a new ElementArrayFinder that contains the results of the\n     * actions.\n     *\n     * @param {function(ElementFinder)} actionFn\n     *\n     * @returns {ElementArrayFinder}\n     * @private\n     */\n    // map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    applyAction_(actionFn) {\n        let callerError = new Error();\n        let actionResults = this.getWebElements()\n            .then((arr) => selenium_webdriver_1.promise.all(arr.map(actionFn)))\n            .then((value) => {\n            return { passed: true, value: value };\n        }, (error) => {\n            return { passed: false, value: error };\n        });\n        let getWebElements = () => actionResults.then(() => this.getWebElements());\n        actionResults = actionResults.then((result) => {\n            if (result.passed) {\n                return result.value;\n            }\n            else {\n                let noSuchErr;\n                if (result.value instanceof Error) {\n                    noSuchErr = result.value;\n                    noSuchErr.stack = noSuchErr.stack + callerError.stack;\n                }\n                else {\n                    noSuchErr = new Error(result.value);\n                    noSuchErr.stack = callerError.stack;\n                }\n                throw noSuchErr;\n            }\n        });\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_, actionResults);\n    }\n    /**\n     * Represents the ElementArrayFinder as an array of ElementFinders.\n     *\n     * @returns {Array.<ElementFinder>} Return a promise, which resolves to a list\n     *     of ElementFinders specified by the locator.\n     */\n    asElementFinders_() {\n        return this.getWebElements().then((arr) => {\n            return arr.map((webElem) => {\n                return ElementFinder.fromWebElement_(this.browser_, webElem, this.locator_);\n            });\n        });\n    }\n    /**\n     * Retrieve the elements represented by the ElementArrayFinder. The input\n     * function is passed to the resulting promise, which resolves to an\n     * array of ElementFinders.\n     *\n     * @alias element.all(locator).then(thenFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * @param {function(Array.<ElementFinder>)} fn\n     * @param {function(Error)} errorFn\n     *\n     * @returns {!webdriver.promise.Promise} A promise which will resolve to\n     *     an array of ElementFinders represented by the ElementArrayFinder.\n     */\n    then(fn, errorFn) {\n        if (this.actionResults_) {\n            return this.actionResults_.then(fn, errorFn);\n        }\n        else {\n            return this.asElementFinders_().then(fn, errorFn);\n        }\n    }\n    /**\n     * Calls the input function on each ElementFinder represented by the\n     * ElementArrayFinder.\n     *\n     * @alias element.all(locator).each(eachFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * @param {function(ElementFinder)} fn Input function\n     *\n     * @returns {!webdriver.promise.Promise} A promise that will resolve when the\n     *     function has been called on all the ElementFinders. The promise will\n     *     resolve to null.\n     */\n    each(fn) {\n        return this.map(fn).then(() => {\n            return null;\n        });\n    }\n    /**\n     * Apply a map function to each element within the ElementArrayFinder. The\n     * callback receives the ElementFinder as the first argument and the index as\n     * a second arg.\n     *\n     * @alias element.all(locator).map(mapFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let items = element.all(by.css('.items li')).map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let items = $$('.items li').map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * @param {function(ElementFinder, number)} mapFn Map function that\n     *     will be applied to each element.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to an array\n     *     of values returned by the map function.\n     */\n    map(mapFn) {\n        return this.asElementFinders_().then((arr) => {\n            let list = arr.map((elementFinder, index) => {\n                let mapResult = mapFn(elementFinder, index);\n                // All nested arrays and objects will also be fully resolved.\n                return selenium_webdriver_1.promise.fullyResolved(mapResult);\n            });\n            return selenium_webdriver_1.promise.all(list);\n        });\n    }\n    ;\n    /**\n     * Apply a reduce function against an accumulator and every element found\n     * using the locator (from left-to-right). The reduce function has to reduce\n     * every element into a single value (the accumulator). Returns promise of\n     * the accumulator. The reduce function receives the accumulator, current\n     * ElementFinder, the index, and the entire array of ElementFinders,\n     * respectively.\n     *\n     * @alias element.all(locator).reduce(reduceFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.items li').reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n     *     reduceFn Reduce function that reduces every element into a single\n     * value.\n     * @param {*} initialValue Initial value of the accumulator.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to the final\n     *     value of the accumulator.\n     */\n    reduce(reduceFn, initialValue) {\n        let valuePromise = selenium_webdriver_1.promise.when(initialValue);\n        return this.asElementFinders_().then((arr) => {\n            return arr.reduce((valuePromise, elementFinder, index) => {\n                return valuePromise.then((value) => {\n                    return reduceFn(value, elementFinder, index, arr);\n                });\n            }, valuePromise);\n        });\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current underlying\n     * elements.\n     *\n     * @view\n     * <span class=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.foo').evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementArrayFinder} which resolves to the\n     *     evaluated expression for each underlying element.\n     *     The result will be resolved as in\n     *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n     *     be resolved as is, functions will be converted to string, and elements\n     *     will be returned as a WebElement.\n     */\n    evaluate(expression) {\n        let evaluationFn = (webElem) => {\n            return webElem.getDriver().executeScript(clientSideScripts.evaluate, webElem, expression);\n        };\n        return this.applyAction_(evaluationFn);\n    }\n    /**\n     * Determine if animation is allowed on the current underlying elements.\n     * @param {string} value\n     *\n     * @example\n     * // Turns off ng-animate animations for all elements in the <body>\n     * element(by.css('body')).allowAnimations(false);\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * $('body').allowAnimations(false);\n     *\n     * @returns {ElementArrayFinder} which resolves to whether animation is\n     * allowed.\n     */\n    allowAnimations(value) {\n        let allowAnimationsTestFn = (webElem) => {\n            return webElem.getDriver().executeScript(clientSideScripts.allowAnimations, webElem, value);\n        };\n        return this.applyAction_(allowAnimationsTestFn);\n    }\n}\nexports.ElementArrayFinder = ElementArrayFinder;\n/**\n * The ElementFinder simply represents a single element of an\n * ElementArrayFinder (and is more like a convenience object). As a result,\n * anything that can be done with an ElementFinder, can also be done using\n * an ElementArrayFinder.\n *\n * The ElementFinder can be treated as a WebElement for most purposes, in\n * particular, you may perform actions (i.e. click, getText) on them as you\n * would a WebElement. Once an action is performed on an ElementFinder, the\n * latest result from the chain can be accessed using the then method.\n * Unlike a WebElement, an ElementFinder will wait for angular to settle before\n * performing finds or actions.\n *\n * ElementFinder can be used to build a chain of locators that is used to find\n * an element. An ElementFinder does not actually attempt to find the element\n * until an action is called, which means they can be set up in helper files\n * before the page is available.\n *\n * @alias element(locator)\n * @view\n * <span>{{person.name}}</span>\n * <span ng-bind=\"person.email\"></span>\n * <input type=\"text\" ng-model=\"person.name\"/>\n *\n * @example\n * // Find element with {{scopelet}} syntax.\n * element(by.binding('person.name')).getText().then(function(name) {\n *   expect(name).toBe('Foo');\n * });\n *\n * // Find element with ng-bind=\"scopelet\" syntax.\n * expect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n *\n * // Find by model.\n * let input = element(by.model('person.name'));\n * input.sendKeys('123');\n * expect(input.getAttribute('value')).toBe('Foo123');\n *\n * @constructor\n * @extends {webdriver.WebElement}\n * @param {ProtractorBrowser} browser_ A browser instance.\n * @param {ElementArrayFinder} elementArrayFinder The ElementArrayFinder\n *     that this is branched from.\n * @returns {ElementFinder}\n */\nclass ElementFinder extends WebdriverWebElement {\n    constructor(browser_, elementArrayFinder) {\n        super();\n        this.browser_ = browser_;\n        this.then = null;\n        if (!elementArrayFinder) {\n            throw new Error('BUG: elementArrayFinder cannot be empty');\n        }\n        this.parentElementArrayFinder = elementArrayFinder;\n        // Only have a `then` method if the parent element array finder\n        // has action results.\n        if (this.parentElementArrayFinder.actionResults_) {\n            // Access the underlying actionResult of ElementFinder.\n            this.then =\n                (fn, errorFn) => {\n                    return this.elementArrayFinder_.then((actionResults) => {\n                        if (!fn) {\n                            return actionResults[0];\n                        }\n                        return fn(actionResults[0]);\n                    }, errorFn);\n                };\n        }\n        // This filter verifies that there is only 1 element returned by the\n        // elementArrayFinder. It will warn if there are more than 1 element and\n        // throw an error if there are no elements.\n        let getWebElements = () => {\n            return elementArrayFinder.getWebElements().then((webElements) => {\n                if (webElements.length === 0) {\n                    throw new selenium_webdriver_1.error.NoSuchElementError('No element found using locator: ' + elementArrayFinder.locator().toString());\n                }\n                else {\n                    if (webElements.length > 1) {\n                        logger.warn('more than one element found for locator ' +\n                            elementArrayFinder.locator().toString() + ' - the first result will be used');\n                    }\n                    return [webElements[0]];\n                }\n            });\n        };\n        // Store a copy of the underlying elementArrayFinder, but with the more\n        // restrictive getWebElements (which checks that there is only 1 element).\n        this.elementArrayFinder_ = new ElementArrayFinder(this.browser_, getWebElements, elementArrayFinder.locator(), elementArrayFinder.actionResults_);\n        WEB_ELEMENT_FUNCTIONS.forEach((fnName) => {\n            (this)[fnName] = (...args) => {\n                return (this.elementArrayFinder_)[fnName]\n                    .apply(this.elementArrayFinder_, args)\n                    .toElementFinder_();\n            };\n        });\n    }\n    static fromWebElement_(browser, webElem, locator) {\n        let getWebElements = () => {\n            return selenium_webdriver_1.promise.when([webElem]);\n        };\n        return new ElementArrayFinder(browser, getWebElements, locator).toElementFinder_();\n    }\n    /**\n     * Create a shallow copy of ElementFinder.\n     *\n     * @returns {!ElementFinder} A shallow copy of this.\n     */\n    clone() {\n        // A shallow copy is all we need since the underlying fields can never be\n        // modified\n        return new ElementFinder(this.browser_, this.parentElementArrayFinder);\n    }\n    /**\n     * @see ElementArrayFinder.prototype.locator\n     *\n     * @returns {webdriver.Locator}\n     */\n    locator() {\n        return this.elementArrayFinder_.locator();\n    }\n    /**\n     * Returns the WebElement represented by this ElementFinder.\n     * Throws the WebDriver error if the element doesn't exist.\n     *\n     * @alias element(locator).getWebElement()\n     * @view\n     * <div class=\"parent\">\n     *   some text\n     * </div>\n     *\n     * @example\n     * // The following four expressions are equivalent.\n     * $('.parent').getWebElement();\n     * element(by.css('.parent')).getWebElement();\n     * browser.driver.findElement(by.css('.parent'));\n     * browser.findElement(by.css('.parent'));\n     *\n     * @returns {webdriver.WebElementPromise}\n     */\n    getWebElement() {\n        let id = this.elementArrayFinder_.getWebElements().then((parentWebElements) => {\n            return parentWebElements[0];\n        });\n        return new selenium_webdriver_1.WebElementPromise(this.browser_.driver, id);\n    }\n    /**\n     * Calls to {@code all} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).all(by.tagName('li'));\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').all(by.tagName('li'));\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n    all(subLocator) {\n        return this.elementArrayFinder_.all(subLocator);\n    }\n    /**\n     * Calls to {@code element} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).element(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     element(by.css('.child'));\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     element(by.css('.child')).\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementFinder}\n     */\n    element(subLocator) {\n        return this.all(subLocator).toElementFinder_();\n    }\n    /**\n     * Calls to {@code $$} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).$$('li');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').$$('li');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder}\n     */\n    $$(selector) {\n        return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Calls to {@code $} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).$(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     $('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     $('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {string} selector A css selector\n     * @returns {ElementFinder}\n     */\n    $(selector) {\n        return this.element(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Determine whether the element is present on the page.\n     *\n     * @view\n     * <span>{{person.name}}</span>\n     *\n     * @example\n     * // Element exists.\n     * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n     *\n     * // Element not present.\n     * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n     *\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the element is present on the page.\n     */\n    isPresent() {\n        return this.parentElementArrayFinder.getWebElements().then((arr) => {\n            if (arr.length === 0) {\n                return false;\n            }\n            return arr[0].isEnabled().then(() => {\n                return true; // is present, whether it is enabled or not\n            }, util_1.falseIfMissing);\n        }, util_1.falseIfMissing);\n    }\n    /**\n     * Same as ElementFinder.isPresent(), except this checks whether the element\n     * identified by the subLocator is present, rather than the current element\n     * finder, i.e.: `element(by.css('#abc')).element(by.css('#def')).isPresent()`\n     * is identical to `element(by.css('#abc')).isElementPresent(by.css('#def'))`.\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * `$('#abc').$('#def').isPresent()` is identical to\n     * `$('#abc').isElementPresent($('#def'))`.\n     *\n     * @see ElementFinder.isPresent\n     *\n     * @param {webdriver.Locator} subLocator Locator for element to look for.\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the subelement is present on the page.\n     */\n    isElementPresent(subLocator) {\n        if (!subLocator) {\n            throw new Error('SubLocator is not supplied as a parameter to ' +\n                '`isElementPresent(subLocator)`. You are probably looking for the ' +\n                'function `isPresent()`.');\n        }\n        return this.element(subLocator).isPresent();\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current element.\n     * @see ElementArrayFinder.prototype.evaluate\n     *\n     * @view\n     * <span id=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element(by.id('foo')).evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementFinder} which resolves to the evaluated expression.\n     */\n    evaluate(expression) {\n        return this.elementArrayFinder_.evaluate(expression).toElementFinder_();\n    }\n    /**\n     * @see ElementArrayFinder.prototype.allowAnimations.\n     * @param {string} value\n     *\n     * @returns {ElementFinder} which resolves to whether animation is allowed.\n     */\n    allowAnimations(value) {\n        return this.elementArrayFinder_.allowAnimations(value).toElementFinder_();\n    }\n    /**\n     * Compares an element to this one for equality.\n     *\n     * @param {!ElementFinder|!webdriver.WebElement} The element to compare to.\n     *\n     * @returns {!webdriver.promise.Promise.<boolean>} A promise that will be\n     *     resolved to whether the two WebElements are equal.\n     */\n    equals(element) {\n        return selenium_webdriver_1.WebElement.equals(this.getWebElement(), element.getWebElement ? element.getWebElement() :\n            element);\n    }\n}\nexports.ElementFinder = ElementFinder;\n/**\n * Shortcut for querying the document directly with css.\n * `element(by.css('.abc'))` is equivalent to `$('.abc')`\n *\n * @alias $(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * let item = $('.count .two');\n * expect(item.getText()).toBe('Second');\n *\n * @param {string} selector A css selector\n * @returns {ElementFinder} which identifies the located\n *     {@link webdriver.WebElement}\n */\nexports.build$ = (element, by) => {\n    return (selector) => {\n        return element(by.css(selector));\n    };\n};\n/**\n * Shortcut for querying the document directly with css.\n * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n *\n * @alias $$(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * // The following protractor expressions are equivalent.\n * let list = element.all(by.css('.count span'));\n * expect(list.count()).toBe(2);\n *\n * list = $$('.count span');\n * expect(list.count()).toBe(2);\n * expect(list.get(0).getText()).toBe('First');\n * expect(list.get(1).getText()).toBe('Second');\n *\n * @param {string} selector a css selector\n * @returns {ElementArrayFinder} which identifies the\n *     array of the located {@link webdriver.WebElement}s.\n */\nexports.build$$ = (element, by) => {\n    return (selector) => {\n        return element.all(by.css(selector));\n    };\n};\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,oBAAoB,GAAGC,OAAO,CAAC,oBAAD,CAApC;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAII,iBAAiB,GAAGJ,OAAO,CAAC,qBAAD,CAA/B;;AACA,IAAIK,MAAM,GAAG,IAAIH,QAAQ,CAACI,MAAb,CAAoB,SAApB,CAAb;;AACA,MAAMC,mBAAN,CAA0B;;AAE1BV,OAAO,CAACU,mBAAR,GAA8BA,mBAA9B;AACA,IAAIC,qBAAqB,GAAG,CACxB,OADwB,EACf,UADe,EACH,YADG,EACW,aADX,EAC0B,cAD1B,EAC0C,SAD1C,EACqD,SADrD,EAExB,aAFwB,EAET,WAFS,EAEI,YAFJ,EAEkB,QAFlB,EAE4B,OAF5B,EAEqC,aAFrC,EAEoD,OAFpD,EAGxB,gBAHwB,CAA5B;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,kBAAN,SAAiCF,mBAAjC,CAAqD;EACjDG,WAAW,CAACC,QAAD,EAAWC,cAAc,GAAG,IAA5B,EAAkCC,QAAlC,EAA4CC,cAAc,GAAG,IAA7D,EAAmE;IAC1E;IACA,KAAKH,QAAL,GAAgBA,QAAhB;IACA,KAAKC,cAAL,GAAsBA,cAAtB;IACA,KAAKC,QAAL,GAAgBA,QAAhB;IACA,KAAKC,cAAL,GAAsBA,cAAtB,CAL0E,CAM1E;IACA;;IACAN,qBAAqB,CAACO,OAAtB,CAA+BC,MAAD,IAAY;MACtC,KAAKA,MAAL,IAAe,CAAC,GAAGC,IAAJ,KAAa;QACxB,IAAIC,QAAQ,GAAIC,OAAD,IAAa;UACxB,OAAOA,OAAO,CAACH,MAAD,CAAP,CAAgBI,KAAhB,CAAsBD,OAAtB,EAA+BF,IAA/B,CAAP;QACH,CAFD;;QAGA,OAAO,KAAKI,YAAL,CAAkBH,QAAlB,CAAP;MACH,CALD;IAMH,CAPD;EAQH;EACD;AACJ;AACA;AACA;AACA;;;EACII,KAAK,GAAG;IACJ;IACA;IACA;IACA,OAAO,IAAIb,kBAAJ,CAAuB,KAAKE,QAA5B,EAAsC,KAAKC,cAA3C,EAA2D,KAAKC,QAAhE,EAA0E,KAAKC,cAA/E,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIS,GAAG,CAACC,OAAD,EAAU;IACT,IAAIC,IAAI,GAAG,KAAKd,QAAhB;;IACA,IAAIC,cAAc,GAAG,MAAM;MACvB,IAAI,KAAKA,cAAL,KAAwB,IAA5B,EAAkC;QAC9B;QACA,OAAOa,IAAI,CAACC,cAAL,CAAoB,cAAcF,OAAlC,EACFG,IADE,CACG,MAAM;UACZ,IAAI1B,UAAU,CAAC2B,mBAAX,CAA+BJ,OAA/B,CAAJ,EAA6C;YACzC,OAAOA,OAAO,CAACK,oBAAR,CAA6BJ,IAAI,CAACK,MAAlC,EAA0C,IAA1C,EAAgDL,IAAI,CAACM,MAArD,CAAP;UACH,CAFD,MAGK;YACD,OAAON,IAAI,CAACK,MAAL,CAAYE,YAAZ,CAAyBR,OAAzB,CAAP;UACH;QACJ,CARM,CAAP;MASH,CAXD,MAYK;QACD,OAAO,KAAKZ,cAAL,GAAsBe,IAAtB,CAA4BM,iBAAD,IAAuB;UACrD;UACA;UACA,IAAIC,mBAAmB,GAAGD,iBAAiB,CAACE,GAAlB,CAAuBC,gBAAD,IAAsB;YAClE,OAAOnC,UAAU,CAAC2B,mBAAX,CAA+BJ,OAA/B,IACHA,OAAO,CAACK,oBAAR,CAA6BJ,IAAI,CAACK,MAAlC,EAA0CM,gBAA1C,EAA4DX,IAAI,CAACM,MAAjE,CADG,GAEHK,gBAAgB,CAACJ,YAAjB,CAA8BR,OAA9B,CAFJ;UAGH,CAJyB,CAA1B,CAHqD,CAQrD;UACA;;UACA,OAAOzB,oBAAoB,CAACsC,OAArB,CAA6Bd,GAA7B,CAAiCW,mBAAjC,EACFP,IADE,CACIW,QAAD,IAAc;YACpB,OAAOA,QAAQ,CAACC,MAAT,CAAgB,CAACC,YAAD,EAAeC,SAAf,KAA6B;cAChD,OAAOD,YAAY,CAACE,MAAb,CAAoBD,SAApB,CAAP;YACH,CAFM,EAEJ,EAFI,CAAP;UAGH,CALM,CAAP;QAMH,CAhBM,CAAP;MAiBH;IACJ,CAhCD;;IAiCA,OAAO,IAAIhC,kBAAJ,CAAuB,KAAKE,QAA5B,EAAsCC,cAAtC,EAAsDY,OAAtD,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACImB,MAAM,CAACC,QAAD,EAAW;IACb,IAAIhC,cAAc,GAAG,MAAM;MACvB,OAAO,KAAKA,cAAL,GAAsBe,IAAtB,CAA4BM,iBAAD,IAAuB;QACrD,IAAIY,IAAI,GAAGZ,iBAAiB,CAACE,GAAlB,CAAsB,CAACC,gBAAD,EAAmBU,KAAnB,KAA6B;UAC1D,IAAIC,aAAa,GAAGC,aAAa,CAACC,eAAd,CAA8B,KAAKtC,QAAnC,EAA6CyB,gBAA7C,EAA+D,KAAKvB,QAApE,CAApB;UACA,OAAO+B,QAAQ,CAACG,aAAD,EAAgBD,KAAhB,CAAf;QACH,CAHU,CAAX;QAIA,OAAO/C,oBAAoB,CAACsC,OAArB,CAA6Bd,GAA7B,CAAiCsB,IAAjC,EAAuClB,IAAvC,CAA6CuB,YAAD,IAAkB;UACjE,OAAOjB,iBAAiB,CAACU,MAAlB,CAAyB,CAACP,gBAAD,EAAmBU,KAAnB,KAA6B;YACzD,OAAOI,YAAY,CAACJ,KAAD,CAAnB;UACH,CAFM,CAAP;QAGH,CAJM,CAAP;MAKH,CAVM,CAAP;IAWH,CAZD;;IAaA,OAAO,IAAIrC,kBAAJ,CAAuB,KAAKE,QAA5B,EAAsCC,cAAtC,EAAsD,KAAKC,QAA3D,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIsC,GAAG,CAACL,KAAD,EAAQ;IACP,IAAIlC,cAAc,GAAG,MAAM;MACvB,OAAOb,oBAAoB,CAACsC,OAArB,CAA6Bd,GAA7B,CAAiC,CAACuB,KAAD,EAAQ,KAAKlC,cAAL,EAAR,CAAjC,EAAiEe,IAAjE,CAAsE,CAAC,CAACyB,CAAD,EAAInB,iBAAJ,CAAD,KAA4B;QACrG,IAAImB,CAAC,GAAG,CAAR,EAAW;UACPA,CAAC,IAAInB,iBAAiB,CAACoB,MAAvB;QACH;;QACD,IAAID,CAAC,GAAG,CAAJ,IAASA,CAAC,IAAInB,iBAAiB,CAACoB,MAApC,EAA4C;UACxC,MAAM,IAAItD,oBAAoB,CAACuD,KAArB,CAA2BC,kBAA/B,CAAkD,4DAA4DT,KAA5D,GACpD,uBADoD,GAC1Bb,iBAAiB,CAACoB,MADQ,GACC,uBADD,GAEpD,UAFoD,GAEvC,KAAKxC,QAAL,CAAc2C,QAAd,EAFX,CAAN;QAGH;;QACD,OAAO,CAACvB,iBAAiB,CAACmB,CAAD,CAAlB,CAAP;MACH,CAVM,CAAP;IAWH,CAZD;;IAaA,OAAO,IAAI3C,kBAAJ,CAAuB,KAAKE,QAA5B,EAAsCC,cAAtC,EAAsD,KAAKC,QAA3D,EAAqE4C,gBAArE,EAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,KAAK,GAAG;IACJ,OAAO,KAAKP,GAAL,CAAS,CAAT,CAAP;EACH;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,IAAI,GAAG;IACH,OAAO,KAAKR,GAAL,CAAS,CAAC,CAAV,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIS,EAAE,CAACC,QAAD,EAAW;IACT,OAAO,KAAKtC,GAAL,CAASxB,oBAAoB,CAAC+D,EAArB,CAAwBC,GAAxB,CAA4BF,QAA5B,CAAT,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIJ,gBAAgB,GAAG;IACf,OAAO,IAAIT,aAAJ,CAAkB,KAAKrC,QAAvB,EAAiC,IAAjC,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIqD,KAAK,GAAG;IACJ,OAAO,KAAKpD,cAAL,GAAsBe,IAAtB,CAA4BsC,GAAD,IAAS;MACvC,OAAOA,GAAG,CAACZ,MAAX;IACH,CAFM,EAEHa,GAAD,IAAS;MACR,IAAIA,GAAG,YAAYnE,oBAAoB,CAACuD,KAArB,CAA2BC,kBAA9C,EAAkE;QAC9D,OAAO,CAAP;MACH,CAFD,MAGK;QACD,MAAMW,GAAN;MACH;IACJ,CATM,CAAP;EAUH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,SAAS,GAAG;IACR,OAAO,KAAKH,KAAL,GAAarC,IAAb,CAAmBqC,KAAD,IAAW;MAChC,OAAOA,KAAK,GAAG,CAAf;IACH,CAFM,CAAP;EAGH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIxC,OAAO,GAAG;IACN,OAAO,KAAKX,QAAZ;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;;;EACAQ,YAAY,CAACH,QAAD,EAAW;IACnB,IAAIkD,WAAW,GAAG,IAAIC,KAAJ,EAAlB;IACA,IAAIC,aAAa,GAAG,KAAK1D,cAAL,GACfe,IADe,CACTsC,GAAD,IAASlE,oBAAoB,CAACsC,OAArB,CAA6Bd,GAA7B,CAAiC0C,GAAG,CAAC9B,GAAJ,CAAQjB,QAAR,CAAjC,CADC,EAEfS,IAFe,CAET7B,KAAD,IAAW;MACjB,OAAO;QAAEyE,MAAM,EAAE,IAAV;QAAgBzE,KAAK,EAAEA;MAAvB,CAAP;IACH,CAJmB,EAIhBwD,KAAD,IAAW;MACV,OAAO;QAAEiB,MAAM,EAAE,KAAV;QAAiBzE,KAAK,EAAEwD;MAAxB,CAAP;IACH,CANmB,CAApB;;IAOA,IAAI1C,cAAc,GAAG,MAAM0D,aAAa,CAAC3C,IAAd,CAAmB,MAAM,KAAKf,cAAL,EAAzB,CAA3B;;IACA0D,aAAa,GAAGA,aAAa,CAAC3C,IAAd,CAAoB6C,MAAD,IAAY;MAC3C,IAAIA,MAAM,CAACD,MAAX,EAAmB;QACf,OAAOC,MAAM,CAAC1E,KAAd;MACH,CAFD,MAGK;QACD,IAAI2E,SAAJ;;QACA,IAAID,MAAM,CAAC1E,KAAP,YAAwBuE,KAA5B,EAAmC;UAC/BI,SAAS,GAAGD,MAAM,CAAC1E,KAAnB;UACA2E,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACC,KAAV,GAAkBN,WAAW,CAACM,KAAhD;QACH,CAHD,MAIK;UACDD,SAAS,GAAG,IAAIJ,KAAJ,CAAUG,MAAM,CAAC1E,KAAjB,CAAZ;UACA2E,SAAS,CAACC,KAAV,GAAkBN,WAAW,CAACM,KAA9B;QACH;;QACD,MAAMD,SAAN;MACH;IACJ,CAhBe,CAAhB;IAiBA,OAAO,IAAIhE,kBAAJ,CAAuB,KAAKE,QAA5B,EAAsCC,cAAtC,EAAsD,KAAKC,QAA3D,EAAqEyD,aAArE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIK,iBAAiB,GAAG;IAChB,OAAO,KAAK/D,cAAL,GAAsBe,IAAtB,CAA4BsC,GAAD,IAAS;MACvC,OAAOA,GAAG,CAAC9B,GAAJ,CAAShB,OAAD,IAAa;QACxB,OAAO6B,aAAa,CAACC,eAAd,CAA8B,KAAKtC,QAAnC,EAA6CQ,OAA7C,EAAsD,KAAKN,QAA3D,CAAP;MACH,CAFM,CAAP;IAGH,CAJM,CAAP;EAKH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIc,IAAI,CAACiD,EAAD,EAAKC,OAAL,EAAc;IACd,IAAI,KAAK/D,cAAT,EAAyB;MACrB,OAAO,KAAKA,cAAL,CAAoBa,IAApB,CAAyBiD,EAAzB,EAA6BC,OAA7B,CAAP;IACH,CAFD,MAGK;MACD,OAAO,KAAKF,iBAAL,GAAyBhD,IAAzB,CAA8BiD,EAA9B,EAAkCC,OAAlC,CAAP;IACH;EACJ;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,IAAI,CAACF,EAAD,EAAK;IACL,OAAO,KAAKzC,GAAL,CAASyC,EAAT,EAAajD,IAAb,CAAkB,MAAM;MAC3B,OAAO,IAAP;IACH,CAFM,CAAP;EAGH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIQ,GA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ByF,OAAvB,EAAgCtF,cAAhC,EAAgDY,OAAhD,EAAyDiC,gBAAzD,EAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACInC,KAAK,GAAG;IACJ;IACA;IACA,OAAO,IAAI0B,aAAJ,CAAkB,KAAKrC,QAAvB,EAAiC,KAAKmF,wBAAtC,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACItE,OAAO,GAAG;IACN,OAAO,KAAKuE,mBAAL,CAAyBvE,OAAzB,EAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI2E,aAAa,GAAG;IACZ,IAAIC,EAAE,GAAG,KAAKL,mBAAL,CAAyBnF,cAAzB,GAA0Ce,IAA1C,CAAgDM,iBAAD,IAAuB;MAC3E,OAAOA,iBAAiB,CAAC,CAAD,CAAxB;IACH,CAFQ,CAAT;IAGA,OAAO,IAAIlC,oBAAoB,CAACsG,iBAAzB,CAA2C,KAAK1F,QAAL,CAAcmB,MAAzD,EAAiEsE,EAAjE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI7E,GAAG,CAAC+E,UAAD,EAAa;IACZ,OAAO,KAAKP,mBAAL,CAAyBxE,GAAzB,CAA6B+E,UAA7B,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,OAAO,CAACD,UAAD,EAAa;IAChB,OAAO,KAAK/E,GAAL,CAAS+E,UAAT,EAAqB7C,gBAArB,EAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIG,EAAE,CAACC,QAAD,EAAW;IACT,OAAO,KAAKtC,GAAL,CAASxB,oBAAoB,CAAC+D,EAArB,CAAwBC,GAAxB,CAA4BF,QAA5B,CAAT,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI2C,CAAC,CAAC3C,QAAD,EAAW;IACR,OAAO,KAAK0C,OAAL,CAAaxG,oBAAoB,CAAC+D,EAArB,CAAwBC,GAAxB,CAA4BF,QAA5B,CAAb,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIM,SAAS,GAAG;IACR,OAAO,KAAK2B,wBAAL,CAA8BlF,cAA9B,GAA+Ce,IAA/C,CAAqDsC,GAAD,IAAS;MAChE,IAAIA,GAAG,CAACZ,MAAJ,KAAe,CAAnB,EAAsB;QAClB,OAAO,KAAP;MACH;;MACD,OAAOY,GAAG,CAAC,CAAD,CAAH,CAAOwC,SAAP,GAAmB9E,IAAnB,CAAwB,MAAM;QACjC,OAAO,IAAP,CADiC,CACpB;MAChB,CAFM,EAEJxB,MAAM,CAACuG,cAFH,CAAP;IAGH,CAPM,EAOJvG,MAAM,CAACuG,cAPH,CAAP;EAQH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,gBAAgB,CAACL,UAAD,EAAa;IACzB,IAAI,CAACA,UAAL,EAAiB;MACb,MAAM,IAAIjC,KAAJ,CAAU,kDACZ,mEADY,GAEZ,yBAFE,CAAN;IAGH;;IACD,OAAO,KAAKkC,OAAL,CAAaD,UAAb,EAAyBnC,SAAzB,EAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACImB,QAAQ,CAACC,UAAD,EAAa;IACjB,OAAO,KAAKQ,mBAAL,CAAyBT,QAAzB,CAAkCC,UAAlC,EAA8C9B,gBAA9C,EAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIkC,eAAe,CAAC7F,KAAD,EAAQ;IACnB,OAAO,KAAKiG,mBAAL,CAAyBJ,eAAzB,CAAyC7F,KAAzC,EAAgD2D,gBAAhD,EAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACImD,MAAM,CAACL,OAAD,EAAU;IACZ,OAAOxG,oBAAoB,CAAC8G,UAArB,CAAgCD,MAAhC,CAAuC,KAAKT,aAAL,EAAvC,EAA6DI,OAAO,CAACJ,aAAR,GAAwBI,OAAO,CAACJ,aAAR,EAAxB,GAChEI,OADG,CAAP;EAEH;;AApU2C;;AAsUhD1G,OAAO,CAACmD,aAAR,GAAwBA,aAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAnD,OAAO,CAACiH,MAAR,GAAiB,CAACP,OAAD,EAAUQ,EAAV,KAAiB;EAC9B,OAAQlD,QAAD,IAAc;IACjB,OAAO0C,OAAO,CAACQ,EAAE,CAAChD,GAAH,CAAOF,QAAP,CAAD,CAAd;EACH,CAFD;AAGH,CAJD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhE,OAAO,CAACmH,OAAR,GAAkB,CAACT,OAAD,EAAUQ,EAAV,KAAiB;EAC/B,OAAQlD,QAAD,IAAc;IACjB,OAAO0C,OAAO,CAAChF,GAAR,CAAYwF,EAAE,CAAChD,GAAH,CAAOF,QAAP,CAAZ,CAAP;EACH,CAFD;AAGH,CAJD"},"metadata":{},"sourceType":"script"}