{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst glob = require(\"glob\");\n\nconst path = require(\"path\");\n\nconst exitCodes_1 = require(\"./exitCodes\");\n\nconst logger_1 = require(\"./logger\");\n\nlet logger = new logger_1.Logger('configParser'); // Coffee is required here to enable config files written in coffee-script.\n\ntry {\n  require('coffee-script').register();\n} catch (e) {// Intentionally blank - ignore if coffee-script is not available.\n} // CoffeeScript lost the hyphen in the module name a long time ago, all new version are named this:\n\n\ntry {\n  require('coffeescript').register();\n} catch (e) {// Intentionally blank - ignore if coffeescript is not available.\n} // LiveScript is required here to enable config files written in LiveScript.\n\n\ntry {\n  require('LiveScript');\n} catch (e) {// Intentionally blank - ignore if LiveScript is not available.\n}\n\nclass ConfigParser {\n  constructor() {\n    // Default configuration.\n    this.config_ = {\n      specs: [],\n      multiCapabilities: [],\n      verboseMultiSessions: false,\n      rootElement: '',\n      allScriptsTimeout: 11000,\n      getPageTimeout: 10000,\n      params: {},\n      framework: 'jasmine',\n      jasmineNodeOpts: {\n        showColors: true,\n        defaultTimeoutInterval: 30 * 1000\n      },\n      seleniumArgs: [],\n      mochaOpts: {\n        ui: 'bdd',\n        reporter: 'list'\n      },\n      configDir: './',\n      noGlobals: false,\n      plugins: [],\n      skipSourceMapSupport: false,\n      ng12Hybrid: false\n    };\n  }\n  /**\n   * Resolve a list of file patterns into a list of individual file paths.\n   *\n   * @param {Array.<string> | string} patterns\n   * @param {=boolean} opt_omitWarnings Whether to omit did not match warnings\n   * @param {=string} opt_relativeTo Path to resolve patterns against\n   *\n   * @return {Array} The resolved file paths.\n   */\n\n\n  static resolveFilePatterns(patterns, opt_omitWarnings, opt_relativeTo) {\n    let resolvedFiles = [];\n    let cwd = opt_relativeTo || process.cwd();\n    patterns = typeof patterns === 'string' ? [patterns] : patterns;\n\n    if (patterns) {\n      for (let fileName of patterns) {\n        let matches = glob.hasMagic(fileName) ? glob.sync(fileName, {\n          cwd\n        }) : [fileName];\n\n        if (!matches.length && !opt_omitWarnings) {\n          logger.warn('pattern ' + fileName + ' did not match any files.');\n        }\n\n        for (let match of matches) {\n          let resolvedPath = path.resolve(cwd, match);\n          resolvedFiles.push(resolvedPath);\n        }\n      }\n    }\n\n    return resolvedFiles;\n  }\n  /**\n   * Returns only the specs that should run currently based on `config.suite`\n   *\n   * @return {Array} An array of globs locating the spec files\n   */\n\n\n  static getSpecs(config) {\n    let specs = [];\n\n    if (config.suite) {\n      config.suite.split(',').forEach(suite => {\n        let suiteList = config.suites ? config.suites[suite] : null;\n\n        if (suiteList == null) {\n          throw new exitCodes_1.ConfigError(logger, 'Unknown test suite: ' + suite);\n        }\n\n        union(specs, makeArray(suiteList));\n      });\n      return specs;\n    }\n\n    if (config.specs.length > 0) {\n      return config.specs;\n    }\n\n    Object.keys(config.suites || {}).forEach(suite => {\n      union(specs, makeArray(config.suites[suite]));\n    });\n    return specs;\n  }\n  /**\n   * Add the options in the parameter config to this runner instance.\n   *\n   * @private\n   * @param {Object} additionalConfig\n   * @param {string} relativeTo the file path to resolve paths against\n   */\n\n\n  addConfig_(additionalConfig, relativeTo) {\n    // All filepaths should be kept relative to the current config location.\n    // This will not affect absolute paths.\n    ['seleniumServerJar', 'chromeDriver', 'firefoxPath', 'frameworkPath', 'geckoDriver', 'onPrepare'].forEach(name => {\n      if (additionalConfig[name] && typeof additionalConfig[name] === 'string') {\n        additionalConfig[name] = path.resolve(relativeTo, additionalConfig[name]);\n      }\n    });\n    merge_(this.config_, additionalConfig);\n  }\n  /**\n   * Public function specialized towards merging in a file's config\n   *\n   * @public\n   * @param {String} filename\n   */\n\n\n  addFileConfig(filename) {\n    if (!filename) {\n      return this;\n    }\n\n    let filePath = path.resolve(process.cwd(), filename);\n    let fileConfig;\n\n    try {\n      fileConfig = require(filePath).config;\n    } catch (e) {\n      throw new exitCodes_1.ConfigError(logger, 'failed loading configuration file ' + filename, e);\n    }\n\n    if (!fileConfig) {\n      throw new exitCodes_1.ConfigError(logger, 'configuration file ' + filename + ' did not export a config object');\n    }\n\n    fileConfig.configDir = path.dirname(filePath);\n    this.addConfig_(fileConfig, fileConfig.configDir);\n    return this;\n  }\n  /**\n   * Public function specialized towards merging in config from argv\n   *\n   * @public\n   * @param {Object} argv\n   */\n\n\n  addConfig(argv) {\n    this.addConfig_(argv, process.cwd());\n    return this;\n  }\n  /**\n   * Public getter for the final, computed config object\n   *\n   * @public\n   * @return {Object} config\n   */\n\n\n  getConfig() {\n    return this.config_;\n  }\n\n}\n\nexports.ConfigParser = ConfigParser;\n/**\n * Merge config objects together.\n *\n * @private\n * @param {Object} into\n * @param {Object} from\n *\n * @return {Object} The 'into' config.\n */\n\nlet merge_ = function (into, from) {\n  for (let key in from) {\n    if (into[key] instanceof Object && !(into[key] instanceof Array) && !(into[key] instanceof Function)) {\n      merge_(into[key], from[key]);\n    } else {\n      into[key] = from[key];\n    }\n  }\n\n  return into;\n};\n/**\n * Returns the item if it's an array or puts the item in an array\n * if it was not one already.\n */\n\n\nlet makeArray = function (item) {\n  return Array.isArray(item) ? item : [item];\n};\n/**\n * Adds to an array all the elements in another array without adding any\n * duplicates\n *\n * @param {string[]} dest The array to add to\n * @param {string[]} src The array to copy from\n */\n\n\nlet union = function (dest, src) {\n  let elems = {};\n\n  for (let key in dest) {\n    elems[dest[key]] = true;\n  }\n\n  for (let key in src) {\n    if (!elems[src[key]]) {\n      dest.push(src[key]);\n      elems[src[key]] = true;\n    }\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","glob","require","path","exitCodes_1","logger_1","logger","Logger","register","e","ConfigParser","constructor","config_","specs","multiCapabilities","verboseMultiSessions","rootElement","allScriptsTimeout","getPageTimeout","params","framework","jasmineNodeOpts","showColors","defaultTimeoutInterval","seleniumArgs","mochaOpts","ui","reporter","configDir","noGlobals","plugins","skipSourceMapSupport","ng12Hybrid","resolveFilePatterns","patterns","opt_omitWarnings","opt_relativeTo","resolvedFiles","cwd","process","fileName","matches","hasMagic","sync","length","warn","match","resolvedPath","resolve","push","getSpecs","config","suite","split","forEach","suiteList","suites","ConfigError","union","makeArray","keys","addConfig_","additionalConfig","relativeTo","name","merge_","addFileConfig","filename","filePath","fileConfig","dirname","addConfig","argv","getConfig","into","from","key","Array","Function","item","isArray","dest","src","elems"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/protractor/built/configParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst glob = require(\"glob\");\nconst path = require(\"path\");\nconst exitCodes_1 = require(\"./exitCodes\");\nconst logger_1 = require(\"./logger\");\nlet logger = new logger_1.Logger('configParser');\n// Coffee is required here to enable config files written in coffee-script.\ntry {\n    require('coffee-script').register();\n}\ncatch (e) {\n    // Intentionally blank - ignore if coffee-script is not available.\n}\n// CoffeeScript lost the hyphen in the module name a long time ago, all new version are named this:\ntry {\n    require('coffeescript').register();\n}\ncatch (e) {\n    // Intentionally blank - ignore if coffeescript is not available.\n}\n// LiveScript is required here to enable config files written in LiveScript.\ntry {\n    require('LiveScript');\n}\ncatch (e) {\n    // Intentionally blank - ignore if LiveScript is not available.\n}\nclass ConfigParser {\n    constructor() {\n        // Default configuration.\n        this.config_ = {\n            specs: [],\n            multiCapabilities: [],\n            verboseMultiSessions: false,\n            rootElement: '',\n            allScriptsTimeout: 11000,\n            getPageTimeout: 10000,\n            params: {},\n            framework: 'jasmine',\n            jasmineNodeOpts: { showColors: true, defaultTimeoutInterval: (30 * 1000) },\n            seleniumArgs: [],\n            mochaOpts: { ui: 'bdd', reporter: 'list' },\n            configDir: './',\n            noGlobals: false,\n            plugins: [],\n            skipSourceMapSupport: false,\n            ng12Hybrid: false\n        };\n    }\n    /**\n     * Resolve a list of file patterns into a list of individual file paths.\n     *\n     * @param {Array.<string> | string} patterns\n     * @param {=boolean} opt_omitWarnings Whether to omit did not match warnings\n     * @param {=string} opt_relativeTo Path to resolve patterns against\n     *\n     * @return {Array} The resolved file paths.\n     */\n    static resolveFilePatterns(patterns, opt_omitWarnings, opt_relativeTo) {\n        let resolvedFiles = [];\n        let cwd = opt_relativeTo || process.cwd();\n        patterns = (typeof patterns === 'string') ? [patterns] : patterns;\n        if (patterns) {\n            for (let fileName of patterns) {\n                let matches = glob.hasMagic(fileName) ? glob.sync(fileName, { cwd }) : [fileName];\n                if (!matches.length && !opt_omitWarnings) {\n                    logger.warn('pattern ' + fileName + ' did not match any files.');\n                }\n                for (let match of matches) {\n                    let resolvedPath = path.resolve(cwd, match);\n                    resolvedFiles.push(resolvedPath);\n                }\n            }\n        }\n        return resolvedFiles;\n    }\n    /**\n     * Returns only the specs that should run currently based on `config.suite`\n     *\n     * @return {Array} An array of globs locating the spec files\n     */\n    static getSpecs(config) {\n        let specs = [];\n        if (config.suite) {\n            config.suite.split(',').forEach((suite) => {\n                let suiteList = config.suites ? config.suites[suite] : null;\n                if (suiteList == null) {\n                    throw new exitCodes_1.ConfigError(logger, 'Unknown test suite: ' + suite);\n                }\n                union(specs, makeArray(suiteList));\n            });\n            return specs;\n        }\n        if (config.specs.length > 0) {\n            return config.specs;\n        }\n        Object.keys(config.suites || {}).forEach((suite) => {\n            union(specs, makeArray(config.suites[suite]));\n        });\n        return specs;\n    }\n    /**\n     * Add the options in the parameter config to this runner instance.\n     *\n     * @private\n     * @param {Object} additionalConfig\n     * @param {string} relativeTo the file path to resolve paths against\n     */\n    addConfig_(additionalConfig, relativeTo) {\n        // All filepaths should be kept relative to the current config location.\n        // This will not affect absolute paths.\n        ['seleniumServerJar', 'chromeDriver', 'firefoxPath', 'frameworkPath', 'geckoDriver',\n            'onPrepare']\n            .forEach((name) => {\n            if (additionalConfig[name] && typeof additionalConfig[name] === 'string') {\n                additionalConfig[name] = path.resolve(relativeTo, additionalConfig[name]);\n            }\n        });\n        merge_(this.config_, additionalConfig);\n    }\n    /**\n     * Public function specialized towards merging in a file's config\n     *\n     * @public\n     * @param {String} filename\n     */\n    addFileConfig(filename) {\n        if (!filename) {\n            return this;\n        }\n        let filePath = path.resolve(process.cwd(), filename);\n        let fileConfig;\n        try {\n            fileConfig = require(filePath).config;\n        }\n        catch (e) {\n            throw new exitCodes_1.ConfigError(logger, 'failed loading configuration file ' + filename, e);\n        }\n        if (!fileConfig) {\n            throw new exitCodes_1.ConfigError(logger, 'configuration file ' + filename + ' did not export a config object');\n        }\n        fileConfig.configDir = path.dirname(filePath);\n        this.addConfig_(fileConfig, fileConfig.configDir);\n        return this;\n    }\n    /**\n     * Public function specialized towards merging in config from argv\n     *\n     * @public\n     * @param {Object} argv\n     */\n    addConfig(argv) {\n        this.addConfig_(argv, process.cwd());\n        return this;\n    }\n    /**\n     * Public getter for the final, computed config object\n     *\n     * @public\n     * @return {Object} config\n     */\n    getConfig() {\n        return this.config_;\n    }\n}\nexports.ConfigParser = ConfigParser;\n/**\n * Merge config objects together.\n *\n * @private\n * @param {Object} into\n * @param {Object} from\n *\n * @return {Object} The 'into' config.\n */\nlet merge_ = function (into, from) {\n    for (let key in from) {\n        if (into[key] instanceof Object && !(into[key] instanceof Array) &&\n            !(into[key] instanceof Function)) {\n            merge_(into[key], from[key]);\n        }\n        else {\n            into[key] = from[key];\n        }\n    }\n    return into;\n};\n/**\n * Returns the item if it's an array or puts the item in an array\n * if it was not one already.\n */\nlet makeArray = function (item) {\n    return Array.isArray(item) ? item : [item];\n};\n/**\n * Adds to an array all the elements in another array without adding any\n * duplicates\n *\n * @param {string[]} dest The array to add to\n * @param {string[]} src The array to copy from\n */\nlet union = function (dest, src) {\n    let elems = {};\n    for (let key in dest) {\n        elems[dest[key]] = true;\n    }\n    for (let key in src) {\n        if (!elems[src[key]]) {\n            dest.push(src[key]);\n            elems[src[key]] = true;\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}