{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nconst util_1 = require(\"./util\");\n/**\n * Represents a library of canned expected conditions that are useful for\n * protractor, especially when dealing with non-angular apps.\n *\n * Each condition returns a function that evaluates to a promise. You may mix\n * multiple conditions using `and`, `or`, and/or `not`. You may also\n * mix these conditions with any other conditions that you write.\n *\n * See ExpectedCondition Class in Selenium WebDriver codebase.\n * http://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html\n *\n *\n * @example\n * var EC = protractor.ExpectedConditions;\n * var button = $('#xyz');\n * var isClickable = EC.elementToBeClickable(button);\n *\n * browser.get(URL);\n * browser.wait(isClickable, 5000); //wait for an element to become clickable\n * button.click();\n *\n * // You can define your own expected condition, which is a function that\n * // takes no parameter and evaluates to a promise of a boolean.\n * var urlChanged = function() {\n *   return browser.getCurrentUrl().then(function(url) {\n *     return url === 'http://www.angularjs.org';\n *   });\n * };\n *\n * // You can customize the conditions with EC.and, EC.or, and EC.not.\n * // Here's a condition to wait for url to change, $('abc') element to contain\n * // text 'bar', and button becomes clickable.\n * var condition = EC.and(urlChanged, EC.textToBePresentInElement($('abc'),\n * 'bar'), isClickable);\n * browser.get(URL);\n * browser.wait(condition, 5000); //wait for condition to be true.\n * button.click();\n *\n * @alias ExpectedConditions\n * @constructor\n */\n\n\nclass ProtractorExpectedConditions {\n  constructor(browser) {\n    this.browser = browser;\n  }\n\n  /**\n   * Negates the result of a promise.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * var titleIsNotFoo = EC.not(EC.titleIs('Foo'));\n   * // Waits for title to become something besides 'foo'.\n   * browser.wait(titleIsNotFoo, 5000);\n   *\n   * @alias ExpectedConditions.not\n   * @param {!function} expectedCondition\n   *\n   * @returns {!function} An expected condition that returns the negated value.\n   */\n  not(expectedCondition) {\n    return () => {\n      return expectedCondition().then(bool => {\n        return !bool;\n      });\n    };\n  }\n  /**\n   * Helper function that is equivalent to the logical_and if defaultRet==true,\n   * or logical_or if defaultRet==false\n   *\n   * @private\n   * @param {boolean} defaultRet\n   * @param {Array.<Function>} fns An array of expected conditions to chain.\n   *\n   * @returns {!function} An expected condition that returns a promise which\n   *     evaluates to the result of the logical chain.\n   */\n\n\n  logicalChain_(defaultRet, fns) {\n    let self = this;\n    return () => {\n      if (fns.length === 0) {\n        return defaultRet;\n      }\n\n      let fn = fns[0];\n      return fn().then(bool => {\n        if (bool === defaultRet) {\n          return self.logicalChain_(defaultRet, fns.slice(1))();\n        } else {\n          return !defaultRet;\n        }\n      });\n    };\n  }\n  /**\n   * Chain a number of expected conditions using logical_and, short circuiting\n   * at the first expected condition that evaluates to false.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * var titleContainsFoo = EC.titleContains('Foo');\n   * var titleIsNotFooBar = EC.not(EC.titleIs('FooBar'));\n   * // Waits for title to contain 'Foo', but is not 'FooBar'\n   * browser.wait(EC.and(titleContainsFoo, titleIsNotFooBar), 5000);\n   *\n   * @alias ExpectedConditions.and\n   * @param {Array.<Function>} fns An array of expected conditions to 'and'\n   * together.\n   *\n   * @returns {!function} An expected condition that returns a promise which\n   *     evaluates to the result of the logical and.\n   */\n\n\n  and(...args) {\n    return this.logicalChain_(true, args);\n  }\n  /**\n   * Chain a number of expected conditions using logical_or, short circuiting\n   * at the first expected condition that evaluates to true.\n   *\n   * @alias ExpectedConditions.or\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * var titleContainsFoo = EC.titleContains('Foo');\n   * var titleContainsBar = EC.titleContains('Bar');\n   * // Waits for title to contain either 'Foo' or 'Bar'\n   * browser.wait(EC.or(titleContainsFoo, titleContainsBar), 5000);\n   *\n   * @param {Array.<Function>} fns An array of expected conditions to 'or'\n   * together.\n   *\n   * @returns {!function} An expected condition that returns a promise which\n   *     evaluates to the result of the logical or.\n   */\n\n\n  or(...args) {\n    return this.logicalChain_(false, args);\n  }\n  /**\n   * Expect an alert to be present.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for an alert pops up.\n   * browser.wait(EC.alertIsPresent(), 5000);\n   *\n   * @alias ExpectedConditions.alertIsPresent\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether an alert is present.\n   */\n\n\n  alertIsPresent() {\n    return () => {\n      return this.browser.driver.switchTo().alert().then(() => {\n        return true;\n      }, err => {\n        if (err instanceof selenium_webdriver_1.error.NoSuchAlertError) {\n          return false;\n        } else {\n          throw err;\n        }\n      });\n    };\n  }\n  /**\n   * An Expectation for checking an element is visible and enabled such that you\n   * can click it.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be clickable.\n   * browser.wait(EC.elementToBeClickable($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.elementToBeClickable\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is clickable.\n   */\n\n\n  elementToBeClickable(elementFinder) {\n    return this.and(this.visibilityOf(elementFinder), () => {\n      return elementFinder.isEnabled().then(util_1.passBoolean, util_1.falseIfMissing);\n    });\n  }\n  /**\n   * An expectation for checking if the given text is present in the\n   * element. Returns false if the elementFinder does not find an element.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to contain the text 'foo'.\n   * browser.wait(EC.textToBePresentInElement($('#abc'), 'foo'), 5000);\n   *\n   * @alias ExpectedConditions.textToBePresentInElement\n   * @param {!ElementFinder} elementFinder The element to check\n   * @param {!string} text The text to verify against\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the text is present in the element.\n   */\n\n\n  textToBePresentInElement(elementFinder, text) {\n    let hasText = () => {\n      return elementFinder.getText().then(actualText => {\n        // MSEdge does not properly remove newlines, which causes false\n        // negatives\n        return actualText.replace(/\\r?\\n|\\r/g, '').indexOf(text) > -1;\n      }, util_1.falseIfMissing);\n    };\n\n    return this.and(this.presenceOf(elementFinder), hasText);\n  }\n  /**\n   * An expectation for checking if the given text is present in the elementâ€™s\n   * value. Returns false if the elementFinder does not find an element.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'myInput' to contain the input 'foo'.\n   * browser.wait(EC.textToBePresentInElementValue($('#myInput'), 'foo'), 5000);\n   *\n   * @alias ExpectedConditions.textToBePresentInElementValue\n   * @param {!ElementFinder} elementFinder The element to check\n   * @param {!string} text The text to verify against\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the text is present in the element's value.\n   */\n\n\n  textToBePresentInElementValue(elementFinder, text) {\n    let hasText = () => {\n      return elementFinder.getAttribute('value').then(actualText => {\n        return actualText.indexOf(text) > -1;\n      }, util_1.falseIfMissing);\n    };\n\n    return this.and(this.presenceOf(elementFinder), hasText);\n  }\n  /**\n   * An expectation for checking that the title contains a case-sensitive\n   * substring.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the title to contain 'foo'.\n   * browser.wait(EC.titleContains('foo'), 5000);\n   *\n   * @alias ExpectedConditions.titleContains\n   * @param {!string} title The fragment of title expected\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the title contains the string.\n   */\n\n\n  titleContains(title) {\n    return () => {\n      return this.browser.driver.getTitle().then(actualTitle => {\n        return actualTitle.indexOf(title) > -1;\n      });\n    };\n  }\n  /**\n   * An expectation for checking the title of a page.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the title to be 'foo'.\n   * browser.wait(EC.titleIs('foo'), 5000);\n   *\n   * @alias ExpectedConditions.titleIs\n   * @param {!string} title The expected title, which must be an exact match.\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the title equals the string.\n   */\n\n\n  titleIs(title) {\n    return () => {\n      return this.browser.driver.getTitle().then(actualTitle => {\n        return actualTitle === title;\n      });\n    };\n  }\n  /**\n   * An expectation for checking that the URL contains a case-sensitive\n   * substring.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the URL to contain 'foo'.\n   * browser.wait(EC.urlContains('foo'), 5000);\n   *\n   * @alias ExpectedConditions.urlContains\n   * @param {!string} url The fragment of URL expected\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the URL contains the string.\n   */\n\n\n  urlContains(url) {\n    return () => {\n      return this.browser.driver.getCurrentUrl().then(actualUrl => {\n        return actualUrl.indexOf(url) > -1;\n      });\n    };\n  }\n  /**\n   * An expectation for checking the URL of a page.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the URL to be 'foo'.\n   * browser.wait(EC.urlIs('foo'), 5000);\n   *\n   * @alias ExpectedConditions.urlIs\n   * @param {!string} url The expected URL, which must be an exact match.\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the url equals the string.\n   */\n\n\n  urlIs(url) {\n    return () => {\n      return this.browser.driver.getCurrentUrl().then(actualUrl => {\n        return actualUrl === url;\n      });\n    };\n  }\n  /**\n   * An expectation for checking that an element is present on the DOM\n   * of a page. This does not necessarily mean that the element is visible.\n   * This is the opposite of 'stalenessOf'.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be present on the dom.\n   * browser.wait(EC.presenceOf($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.presenceOf\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is present.\n   */\n\n\n  presenceOf(elementFinder) {\n    return elementFinder.isPresent.bind(elementFinder);\n  }\n\n  /**\n   * An expectation for checking that an element is not attached to the DOM\n   * of a page. This is the opposite of 'presenceOf'.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be no longer present on the dom.\n   * browser.wait(EC.stalenessOf($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.stalenessOf\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is stale.\n   */\n  stalenessOf(elementFinder) {\n    return this.not(this.presenceOf(elementFinder));\n  }\n  /**\n   * An expectation for checking that an element is present on the DOM of a\n   * page and visible. Visibility means that the element is not only displayed\n   * but also has a height and width that is greater than 0. This is the\n   * opposite\n   * of 'invisibilityOf'.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be visible on the dom.\n   * browser.wait(EC.visibilityOf($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.visibilityOf\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is visible.\n   */\n\n\n  visibilityOf(elementFinder) {\n    return this.and(this.presenceOf(elementFinder), () => {\n      return elementFinder.isDisplayed().then(util_1.passBoolean, util_1.falseIfMissing);\n    });\n  }\n  /**\n   * An expectation for checking that an element is either invisible or not\n   * present on the DOM. This is the opposite of 'visibilityOf'.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'abc' to be no longer visible on the dom.\n   * browser.wait(EC.invisibilityOf($('#abc')), 5000);\n   *\n   * @alias ExpectedConditions.invisibilityOf\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is invisible.\n   */\n\n\n  invisibilityOf(elementFinder) {\n    return this.not(this.visibilityOf(elementFinder));\n  }\n  /**\n   * An expectation for checking the selection is selected.\n   *\n   * @example\n   * var EC = protractor.ExpectedConditions;\n   * // Waits for the element with id 'myCheckbox' to be selected.\n   * browser.wait(EC.elementToBeSelected($('#myCheckbox')), 5000);\n   *\n   * @alias ExpectedConditions.elementToBeSelected\n   * @param {!ElementFinder} elementFinder The element to check\n   *\n   * @returns {!function} An expected condition that returns a promise\n   *     representing whether the element is selected.\n   */\n\n\n  elementToBeSelected(elementFinder) {\n    return this.and(this.presenceOf(elementFinder), () => {\n      return elementFinder.isSelected().then(util_1.passBoolean, util_1.falseIfMissing);\n    });\n  }\n\n}\n\nexports.ProtractorExpectedConditions = ProtractorExpectedConditions;","map":{"version":3,"names":["Object","defineProperty","exports","value","selenium_webdriver_1","require","util_1","ProtractorExpectedConditions","constructor","browser","not","expectedCondition","then","bool","logicalChain_","defaultRet","fns","self","length","fn","slice","and","args","or","alertIsPresent","driver","switchTo","alert","err","error","NoSuchAlertError","elementToBeClickable","elementFinder","visibilityOf","isEnabled","passBoolean","falseIfMissing","textToBePresentInElement","text","hasText","getText","actualText","replace","indexOf","presenceOf","textToBePresentInElementValue","getAttribute","titleContains","title","getTitle","actualTitle","titleIs","urlContains","url","getCurrentUrl","actualUrl","urlIs","isPresent","bind","stalenessOf","isDisplayed","invisibilityOf","elementToBeSelected","isSelected"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/protractor/built/expectedConditions.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\nconst util_1 = require(\"./util\");\n/**\n * Represents a library of canned expected conditions that are useful for\n * protractor, especially when dealing with non-angular apps.\n *\n * Each condition returns a function that evaluates to a promise. You may mix\n * multiple conditions using `and`, `or`, and/or `not`. You may also\n * mix these conditions with any other conditions that you write.\n *\n * See ExpectedCondition Class in Selenium WebDriver codebase.\n * http://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html\n *\n *\n * @example\n * var EC = protractor.ExpectedConditions;\n * var button = $('#xyz');\n * var isClickable = EC.elementToBeClickable(button);\n *\n * browser.get(URL);\n * browser.wait(isClickable, 5000); //wait for an element to become clickable\n * button.click();\n *\n * // You can define your own expected condition, which is a function that\n * // takes no parameter and evaluates to a promise of a boolean.\n * var urlChanged = function() {\n *   return browser.getCurrentUrl().then(function(url) {\n *     return url === 'http://www.angularjs.org';\n *   });\n * };\n *\n * // You can customize the conditions with EC.and, EC.or, and EC.not.\n * // Here's a condition to wait for url to change, $('abc') element to contain\n * // text 'bar', and button becomes clickable.\n * var condition = EC.and(urlChanged, EC.textToBePresentInElement($('abc'),\n * 'bar'), isClickable);\n * browser.get(URL);\n * browser.wait(condition, 5000); //wait for condition to be true.\n * button.click();\n *\n * @alias ExpectedConditions\n * @constructor\n */\nclass ProtractorExpectedConditions {\n    constructor(browser) {\n        this.browser = browser;\n    }\n    ;\n    /**\n     * Negates the result of a promise.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleIsNotFoo = EC.not(EC.titleIs('Foo'));\n     * // Waits for title to become something besides 'foo'.\n     * browser.wait(titleIsNotFoo, 5000);\n     *\n     * @alias ExpectedConditions.not\n     * @param {!function} expectedCondition\n     *\n     * @returns {!function} An expected condition that returns the negated value.\n     */\n    not(expectedCondition) {\n        return () => {\n            return expectedCondition().then((bool) => {\n                return !bool;\n            });\n        };\n    }\n    /**\n     * Helper function that is equivalent to the logical_and if defaultRet==true,\n     * or logical_or if defaultRet==false\n     *\n     * @private\n     * @param {boolean} defaultRet\n     * @param {Array.<Function>} fns An array of expected conditions to chain.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical chain.\n     */\n    logicalChain_(defaultRet, fns) {\n        let self = this;\n        return () => {\n            if (fns.length === 0) {\n                return defaultRet;\n            }\n            let fn = fns[0];\n            return fn().then((bool) => {\n                if (bool === defaultRet) {\n                    return self.logicalChain_(defaultRet, fns.slice(1))();\n                }\n                else {\n                    return !defaultRet;\n                }\n            });\n        };\n    }\n    /**\n     * Chain a number of expected conditions using logical_and, short circuiting\n     * at the first expected condition that evaluates to false.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleContainsFoo = EC.titleContains('Foo');\n     * var titleIsNotFooBar = EC.not(EC.titleIs('FooBar'));\n     * // Waits for title to contain 'Foo', but is not 'FooBar'\n     * browser.wait(EC.and(titleContainsFoo, titleIsNotFooBar), 5000);\n     *\n     * @alias ExpectedConditions.and\n     * @param {Array.<Function>} fns An array of expected conditions to 'and'\n     * together.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical and.\n     */\n    and(...args) {\n        return this.logicalChain_(true, args);\n    }\n    /**\n     * Chain a number of expected conditions using logical_or, short circuiting\n     * at the first expected condition that evaluates to true.\n     *\n     * @alias ExpectedConditions.or\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * var titleContainsFoo = EC.titleContains('Foo');\n     * var titleContainsBar = EC.titleContains('Bar');\n     * // Waits for title to contain either 'Foo' or 'Bar'\n     * browser.wait(EC.or(titleContainsFoo, titleContainsBar), 5000);\n     *\n     * @param {Array.<Function>} fns An array of expected conditions to 'or'\n     * together.\n     *\n     * @returns {!function} An expected condition that returns a promise which\n     *     evaluates to the result of the logical or.\n     */\n    or(...args) {\n        return this.logicalChain_(false, args);\n    }\n    /**\n     * Expect an alert to be present.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for an alert pops up.\n     * browser.wait(EC.alertIsPresent(), 5000);\n     *\n     * @alias ExpectedConditions.alertIsPresent\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether an alert is present.\n     */\n    alertIsPresent() {\n        return () => {\n            return this.browser.driver.switchTo().alert().then(() => {\n                return true;\n            }, (err) => {\n                if (err instanceof selenium_webdriver_1.error.NoSuchAlertError) {\n                    return false;\n                }\n                else {\n                    throw err;\n                }\n            });\n        };\n    }\n    /**\n     * An Expectation for checking an element is visible and enabled such that you\n     * can click it.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be clickable.\n     * browser.wait(EC.elementToBeClickable($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.elementToBeClickable\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is clickable.\n     */\n    elementToBeClickable(elementFinder) {\n        return this.and(this.visibilityOf(elementFinder), () => {\n            return elementFinder.isEnabled().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n    /**\n     * An expectation for checking if the given text is present in the\n     * element. Returns false if the elementFinder does not find an element.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to contain the text 'foo'.\n     * browser.wait(EC.textToBePresentInElement($('#abc'), 'foo'), 5000);\n     *\n     * @alias ExpectedConditions.textToBePresentInElement\n     * @param {!ElementFinder} elementFinder The element to check\n     * @param {!string} text The text to verify against\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the text is present in the element.\n     */\n    textToBePresentInElement(elementFinder, text) {\n        let hasText = () => {\n            return elementFinder.getText().then((actualText) => {\n                // MSEdge does not properly remove newlines, which causes false\n                // negatives\n                return actualText.replace(/\\r?\\n|\\r/g, '').indexOf(text) > -1;\n            }, util_1.falseIfMissing);\n        };\n        return this.and(this.presenceOf(elementFinder), hasText);\n    }\n    /**\n     * An expectation for checking if the given text is present in the elementâ€™s\n     * value. Returns false if the elementFinder does not find an element.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'myInput' to contain the input 'foo'.\n     * browser.wait(EC.textToBePresentInElementValue($('#myInput'), 'foo'), 5000);\n     *\n     * @alias ExpectedConditions.textToBePresentInElementValue\n     * @param {!ElementFinder} elementFinder The element to check\n     * @param {!string} text The text to verify against\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the text is present in the element's value.\n     */\n    textToBePresentInElementValue(elementFinder, text) {\n        let hasText = () => {\n            return elementFinder.getAttribute('value').then((actualText) => {\n                return actualText.indexOf(text) > -1;\n            }, util_1.falseIfMissing);\n        };\n        return this.and(this.presenceOf(elementFinder), hasText);\n    }\n    /**\n     * An expectation for checking that the title contains a case-sensitive\n     * substring.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the title to contain 'foo'.\n     * browser.wait(EC.titleContains('foo'), 5000);\n     *\n     * @alias ExpectedConditions.titleContains\n     * @param {!string} title The fragment of title expected\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the title contains the string.\n     */\n    titleContains(title) {\n        return () => {\n            return this.browser.driver.getTitle().then((actualTitle) => {\n                return actualTitle.indexOf(title) > -1;\n            });\n        };\n    }\n    /**\n     * An expectation for checking the title of a page.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the title to be 'foo'.\n     * browser.wait(EC.titleIs('foo'), 5000);\n     *\n     * @alias ExpectedConditions.titleIs\n     * @param {!string} title The expected title, which must be an exact match.\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the title equals the string.\n     */\n    titleIs(title) {\n        return () => {\n            return this.browser.driver.getTitle().then((actualTitle) => {\n                return actualTitle === title;\n            });\n        };\n    }\n    /**\n     * An expectation for checking that the URL contains a case-sensitive\n     * substring.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the URL to contain 'foo'.\n     * browser.wait(EC.urlContains('foo'), 5000);\n     *\n     * @alias ExpectedConditions.urlContains\n     * @param {!string} url The fragment of URL expected\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the URL contains the string.\n     */\n    urlContains(url) {\n        return () => {\n            return this.browser.driver.getCurrentUrl().then((actualUrl) => {\n                return actualUrl.indexOf(url) > -1;\n            });\n        };\n    }\n    /**\n     * An expectation for checking the URL of a page.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the URL to be 'foo'.\n     * browser.wait(EC.urlIs('foo'), 5000);\n     *\n     * @alias ExpectedConditions.urlIs\n     * @param {!string} url The expected URL, which must be an exact match.\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the url equals the string.\n     */\n    urlIs(url) {\n        return () => {\n            return this.browser.driver.getCurrentUrl().then((actualUrl) => {\n                return actualUrl === url;\n            });\n        };\n    }\n    /**\n     * An expectation for checking that an element is present on the DOM\n     * of a page. This does not necessarily mean that the element is visible.\n     * This is the opposite of 'stalenessOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be present on the dom.\n     * browser.wait(EC.presenceOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.presenceOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is present.\n     */\n    presenceOf(elementFinder) {\n        return elementFinder.isPresent.bind(elementFinder);\n    }\n    ;\n    /**\n     * An expectation for checking that an element is not attached to the DOM\n     * of a page. This is the opposite of 'presenceOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be no longer present on the dom.\n     * browser.wait(EC.stalenessOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.stalenessOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is stale.\n     */\n    stalenessOf(elementFinder) {\n        return this.not(this.presenceOf(elementFinder));\n    }\n    /**\n     * An expectation for checking that an element is present on the DOM of a\n     * page and visible. Visibility means that the element is not only displayed\n     * but also has a height and width that is greater than 0. This is the\n     * opposite\n     * of 'invisibilityOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be visible on the dom.\n     * browser.wait(EC.visibilityOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.visibilityOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is visible.\n     */\n    visibilityOf(elementFinder) {\n        return this.and(this.presenceOf(elementFinder), () => {\n            return elementFinder.isDisplayed().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n    /**\n     * An expectation for checking that an element is either invisible or not\n     * present on the DOM. This is the opposite of 'visibilityOf'.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'abc' to be no longer visible on the dom.\n     * browser.wait(EC.invisibilityOf($('#abc')), 5000);\n     *\n     * @alias ExpectedConditions.invisibilityOf\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is invisible.\n     */\n    invisibilityOf(elementFinder) {\n        return this.not(this.visibilityOf(elementFinder));\n    }\n    /**\n     * An expectation for checking the selection is selected.\n     *\n     * @example\n     * var EC = protractor.ExpectedConditions;\n     * // Waits for the element with id 'myCheckbox' to be selected.\n     * browser.wait(EC.elementToBeSelected($('#myCheckbox')), 5000);\n     *\n     * @alias ExpectedConditions.elementToBeSelected\n     * @param {!ElementFinder} elementFinder The element to check\n     *\n     * @returns {!function} An expected condition that returns a promise\n     *     representing whether the element is selected.\n     */\n    elementToBeSelected(elementFinder) {\n        return this.and(this.presenceOf(elementFinder), () => {\n            return elementFinder.isSelected().then(util_1.passBoolean, util_1.falseIfMissing);\n        });\n    }\n}\nexports.ProtractorExpectedConditions = ProtractorExpectedConditions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}