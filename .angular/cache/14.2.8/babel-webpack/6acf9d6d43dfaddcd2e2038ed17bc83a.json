{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http = require(\"http\");\n\nconst angular_wait_barrier_1 = require(\"./angular_wait_barrier\");\n\nconst highlight_delay_barrier_1 = require(\"./highlight_delay_barrier\");\n\nconst simple_webdriver_client_1 = require(\"./simple_webdriver_client\");\n\nconst webdriver_proxy_1 = require(\"./webdriver_proxy\");\n\nexports.BP_PREFIX = 'bpproxy';\n/**\n * The stability proxy is an http server responsible for intercepting\n * JSON webdriver commands. It keeps track of whether the page under test\n * needs to wait for page stability, and initiates a wait if so.\n */\n\nclass BlockingProxy {\n  constructor(seleniumAddress, highlightDelay = null) {\n    this.server = http.createServer(this.requestListener.bind(this));\n    this.proxy = new webdriver_proxy_1.WebDriverProxy(seleniumAddress);\n    let client = new simple_webdriver_client_1.SimpleWebDriverClient(seleniumAddress);\n    this.waitBarrier = new angular_wait_barrier_1.AngularWaitBarrier(client);\n    this.highlightBarrier = new highlight_delay_barrier_1.HighlightDelayBarrier(client, highlightDelay);\n    this.proxy.addBarrier(this.waitBarrier);\n    this.proxy.addBarrier(this.highlightBarrier);\n  }\n  /**\n   * This command is for the proxy server, not to be forwarded to Selenium.\n   */\n\n\n  static isProxyCommand(commandPath) {\n    return commandPath.split('/')[1] === exports.BP_PREFIX;\n  }\n  /**\n   * Turn on WebDriver logging.\n   *\n   * @param logDir The directory to create logs in.\n   */\n\n\n  enableLogging(logDir) {\n    this.waitBarrier.enableLogging(logDir);\n  }\n  /**\n   * Override the logger instance. Only used for testing.\n   */\n\n\n  setLogger(logger) {\n    this.waitBarrier.setLogger(logger);\n  }\n  /**\n   * Change the parameters used by the wait function.\n   */\n\n\n  setWaitParams(rootEl) {\n    this.waitBarrier.setRootSelector(rootEl);\n  }\n\n  handleProxyCommand(message, data, response) {\n    let command = message.url.split('/')[2];\n\n    switch (command) {\n      case 'waitEnabled':\n        if (message.method === 'GET') {\n          response.writeHead(200);\n          response.write(JSON.stringify({\n            value: this.waitBarrier.enabled\n          }));\n          response.end();\n        } else if (message.method === 'POST') {\n          response.writeHead(200);\n          this.waitBarrier.enabled = JSON.parse(data).value;\n          response.end();\n        } else {\n          response.writeHead(405);\n          response.write('Invalid method');\n          response.end();\n        }\n\n        break;\n\n      case 'waitParams':\n        if (message.method === 'GET') {\n          response.writeHead(200);\n          response.write(JSON.stringify({\n            rootSelector: this.waitBarrier.rootSelector\n          }));\n          response.end();\n        } else if (message.method === 'POST') {\n          response.writeHead(200);\n          this.waitBarrier.rootSelector = JSON.parse(data).rootSelector;\n          response.end();\n        } else {\n          response.writeHead(405);\n          response.write('Invalid method');\n          response.end();\n        }\n\n        break;\n\n      default:\n        response.writeHead(404);\n        response.write('Unknown stabilizer proxy command');\n        response.end();\n    }\n  }\n\n  requestListener(originalRequest, response) {\n    if (BlockingProxy.isProxyCommand(originalRequest.url)) {\n      let commandData = '';\n      originalRequest.on('data', d => {\n        commandData += d;\n      });\n      originalRequest.on('end', () => {\n        this.handleProxyCommand(originalRequest, commandData, response);\n      });\n      return;\n    } // OK to ignore the promise returned by this.\n\n\n    this.proxy.handleRequest(originalRequest, response);\n  }\n\n  listen(port) {\n    this.server.listen(port);\n    let actualPort = this.server.address().port;\n    return actualPort;\n  }\n\n  quit() {\n    return new Promise(resolve => {\n      this.server.close(resolve);\n    });\n  }\n\n}\n\nexports.BlockingProxy = BlockingProxy;","map":{"version":3,"names":["Object","defineProperty","exports","value","http","require","angular_wait_barrier_1","highlight_delay_barrier_1","simple_webdriver_client_1","webdriver_proxy_1","BP_PREFIX","BlockingProxy","constructor","seleniumAddress","highlightDelay","server","createServer","requestListener","bind","proxy","WebDriverProxy","client","SimpleWebDriverClient","waitBarrier","AngularWaitBarrier","highlightBarrier","HighlightDelayBarrier","addBarrier","isProxyCommand","commandPath","split","enableLogging","logDir","setLogger","logger","setWaitParams","rootEl","setRootSelector","handleProxyCommand","message","data","response","command","url","method","writeHead","write","JSON","stringify","enabled","end","parse","rootSelector","originalRequest","commandData","on","d","handleRequest","listen","port","actualPort","address","quit","Promise","resolve","close"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/blocking-proxy/built/lib/blockingproxy.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst angular_wait_barrier_1 = require(\"./angular_wait_barrier\");\nconst highlight_delay_barrier_1 = require(\"./highlight_delay_barrier\");\nconst simple_webdriver_client_1 = require(\"./simple_webdriver_client\");\nconst webdriver_proxy_1 = require(\"./webdriver_proxy\");\nexports.BP_PREFIX = 'bpproxy';\n/**\n * The stability proxy is an http server responsible for intercepting\n * JSON webdriver commands. It keeps track of whether the page under test\n * needs to wait for page stability, and initiates a wait if so.\n */\nclass BlockingProxy {\n    constructor(seleniumAddress, highlightDelay = null) {\n        this.server = http.createServer(this.requestListener.bind(this));\n        this.proxy = new webdriver_proxy_1.WebDriverProxy(seleniumAddress);\n        let client = new simple_webdriver_client_1.SimpleWebDriverClient(seleniumAddress);\n        this.waitBarrier = new angular_wait_barrier_1.AngularWaitBarrier(client);\n        this.highlightBarrier = new highlight_delay_barrier_1.HighlightDelayBarrier(client, highlightDelay);\n        this.proxy.addBarrier(this.waitBarrier);\n        this.proxy.addBarrier(this.highlightBarrier);\n    }\n    /**\n     * This command is for the proxy server, not to be forwarded to Selenium.\n     */\n    static isProxyCommand(commandPath) {\n        return (commandPath.split('/')[1] === exports.BP_PREFIX);\n    }\n    /**\n     * Turn on WebDriver logging.\n     *\n     * @param logDir The directory to create logs in.\n     */\n    enableLogging(logDir) {\n        this.waitBarrier.enableLogging(logDir);\n    }\n    /**\n     * Override the logger instance. Only used for testing.\n     */\n    setLogger(logger) {\n        this.waitBarrier.setLogger(logger);\n    }\n    /**\n     * Change the parameters used by the wait function.\n     */\n    setWaitParams(rootEl) {\n        this.waitBarrier.setRootSelector(rootEl);\n    }\n    handleProxyCommand(message, data, response) {\n        let command = message.url.split('/')[2];\n        switch (command) {\n            case 'waitEnabled':\n                if (message.method === 'GET') {\n                    response.writeHead(200);\n                    response.write(JSON.stringify({ value: this.waitBarrier.enabled }));\n                    response.end();\n                }\n                else if (message.method === 'POST') {\n                    response.writeHead(200);\n                    this.waitBarrier.enabled = JSON.parse(data).value;\n                    response.end();\n                }\n                else {\n                    response.writeHead(405);\n                    response.write('Invalid method');\n                    response.end();\n                }\n                break;\n            case 'waitParams':\n                if (message.method === 'GET') {\n                    response.writeHead(200);\n                    response.write(JSON.stringify({ rootSelector: this.waitBarrier.rootSelector }));\n                    response.end();\n                }\n                else if (message.method === 'POST') {\n                    response.writeHead(200);\n                    this.waitBarrier.rootSelector = JSON.parse(data).rootSelector;\n                    response.end();\n                }\n                else {\n                    response.writeHead(405);\n                    response.write('Invalid method');\n                    response.end();\n                }\n                break;\n            default:\n                response.writeHead(404);\n                response.write('Unknown stabilizer proxy command');\n                response.end();\n        }\n    }\n    requestListener(originalRequest, response) {\n        if (BlockingProxy.isProxyCommand(originalRequest.url)) {\n            let commandData = '';\n            originalRequest.on('data', (d) => {\n                commandData += d;\n            });\n            originalRequest.on('end', () => {\n                this.handleProxyCommand(originalRequest, commandData, response);\n            });\n            return;\n        }\n        // OK to ignore the promise returned by this.\n        this.proxy.handleRequest(originalRequest, response);\n    }\n    listen(port) {\n        this.server.listen(port);\n        let actualPort = this.server.address().port;\n        return actualPort;\n    }\n    quit() {\n        return new Promise((resolve) => {\n            this.server.close(resolve);\n        });\n    }\n}\nexports.BlockingProxy = BlockingProxy;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}