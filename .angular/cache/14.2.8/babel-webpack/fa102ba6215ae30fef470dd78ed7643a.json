{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst q = require(\"q\");\n\nconst webdriver = require(\"selenium-webdriver\");\n\nconst configParser_1 = require(\"./configParser\");\n\nconst logger_1 = require(\"./logger\");\n\nconst ptor_1 = require(\"./ptor\");\n\nlet logger = new logger_1.Logger('plugins');\nvar PromiseType;\n\n(function (PromiseType) {\n  PromiseType[PromiseType[\"Q\"] = 0] = \"Q\";\n  PromiseType[PromiseType[\"WEBDRIVER\"] = 1] = \"WEBDRIVER\";\n})(PromiseType = exports.PromiseType || (exports.PromiseType = {}));\n/**\n * The plugin API for Protractor.  Note that this API is unstable. See\n * plugins/README.md for more information.\n *\n * @constructor\n * @param {Object} config parsed from the config file\n */\n\n\nclass Plugins {\n  constructor(config) {\n    /**\n     * @see docs/plugins.md#writing-plugins for information on these functions\n     */\n    this.setup = this.pluginFunFactory('setup', PromiseType.Q);\n    this.onPrepare = this.pluginFunFactory('onPrepare', PromiseType.Q);\n    this.teardown = this.pluginFunFactory('teardown', PromiseType.Q);\n    this.postResults = this.pluginFunFactory('postResults', PromiseType.Q);\n    this.postTest = this.pluginFunFactory('postTest', PromiseType.Q);\n    this.onPageLoad = this.pluginFunFactory('onPageLoad', PromiseType.WEBDRIVER);\n    this.onPageStable = this.pluginFunFactory('onPageStable', PromiseType.WEBDRIVER);\n    this.waitForPromise = this.pluginFunFactory('waitForPromise', PromiseType.WEBDRIVER);\n    this.waitForCondition = this.pluginFunFactory('waitForCondition', PromiseType.WEBDRIVER, true);\n    this.pluginObjs = [];\n    this.assertions = {};\n    this.resultsReported = false;\n\n    if (config.plugins) {\n      config.plugins.forEach((pluginConf, i) => {\n        let path;\n\n        if (pluginConf.path) {\n          path = configParser_1.ConfigParser.resolveFilePatterns(pluginConf.path, true, config.configDir)[0];\n\n          if (!path) {\n            throw new Error('Invalid path to plugin: ' + pluginConf.path);\n          }\n        } else {\n          path = pluginConf.package;\n        }\n\n        let pluginObj;\n\n        if (path) {\n          pluginObj = require(path);\n        } else if (pluginConf.inline) {\n          pluginObj = pluginConf.inline;\n        } else {\n          throw new Error('Plugin configuration did not contain a valid path or ' + 'inline definition.');\n        }\n\n        this.annotatePluginObj(pluginObj, pluginConf, i);\n        logger.debug('Plugin \"' + pluginObj.name + '\" loaded.');\n        this.pluginObjs.push(pluginObj);\n      });\n    }\n  }\n\n  /**\n   * Adds properties to a plugin's object\n   *\n   * @see docs/plugins.md#provided-properties-and-functions\n   */\n  annotatePluginObj(obj, conf, i) {\n    let addAssertion = (info, passed, message) => {\n      if (this.resultsReported) {\n        throw new Error('Cannot add new tests results, since they were already ' + 'reported.');\n      }\n\n      info = info || {};\n      const specName = info.specName || obj.name + ' Plugin Tests';\n      const assertion = {\n        passed: passed\n      };\n\n      if (!passed) {\n        assertion.errorMsg = message;\n\n        if (info.stackTrace) {\n          assertion.stackTrace = info.stackTrace;\n        }\n      }\n\n      this.assertions[specName] = this.assertions[specName] || [];\n      this.assertions[specName].push(assertion);\n    };\n\n    obj.name = obj.name || conf.name || conf.path || conf.package || 'Plugin #' + i;\n    obj.config = conf;\n\n    obj.addFailure = (message, info) => {\n      addAssertion(info, false, message);\n    };\n\n    obj.addSuccess = options => {\n      addAssertion(options, true);\n    };\n\n    obj.addWarning = (message, options) => {\n      options = options || {};\n      logger.warn('Warning ' + (options.specName ? 'in ' + options.specName : 'from \"' + obj.name + '\" plugin') + ': ' + message);\n    };\n  }\n\n  printPluginResults(specResults) {\n    const green = '\\x1b[32m';\n    const red = '\\x1b[31m';\n    const normalColor = '\\x1b[39m';\n\n    const printResult = (message, pass) => {\n      logger.info(pass ? green : red, '\\t', pass ? 'Pass: ' : 'Fail: ', message, normalColor);\n    };\n\n    for (const specResult of specResults) {\n      const passed = specResult.assertions.map(x => x.passed).reduce((x, y) => x && y, true);\n      printResult(specResult.description, passed);\n\n      if (!passed) {\n        for (const assertion of specResult.assertions) {\n          if (!assertion.passed) {\n            logger.error('\\t\\t' + assertion.errorMsg);\n\n            if (assertion.stackTrace) {\n              logger.error('\\t\\t' + assertion.stackTrace.replace(/\\n/g, '\\n\\t\\t'));\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Gets the tests results generated by any plugins\n   *\n   * @see lib/frameworks/README.md#requirements for a complete description of what\n   *     the results object must look like\n   *\n   * @return {Object} The results object\n   */\n\n\n  getResults() {\n    const results = {\n      failedCount: 0,\n      specResults: []\n    };\n\n    for (const specName in this.assertions) {\n      results.specResults.push({\n        description: specName,\n        assertions: this.assertions[specName]\n      });\n      results.failedCount += this.assertions[specName].filter(assertion => !assertion.passed).length;\n    }\n\n    this.printPluginResults(results.specResults);\n    this.resultsReported = true;\n    return results;\n  }\n\n  /**\n   * Returns true if any loaded plugin has skipAngularStability enabled.\n   *\n   * @return {boolean}\n   */\n  skipAngularStability() {\n    const result = this.pluginObjs.some(pluginObj => pluginObj.skipAngularStability);\n    return result;\n  }\n\n  /**\n   * Calls a function from a plugin safely.  If the plugin's function throws an\n   * exception or returns a rejected promise, that failure will be logged as a\n   * failed test result instead of crashing protractor.  If the tests results have\n   * already been reported, the failure will be logged to the console.\n   *\n   * @param {Object} pluginObj The plugin object containing the function to be run\n   * @param {string} funName The name of the function we want to run\n   * @param {*[]} args The arguments we want to invoke the function with\n   * @param {PromiseType} promiseType The type of promise (WebDriver or Q) that\n   *    should be used\n   * @param {boolean} resultsReported If the results have already been reported\n   * @param {*} failReturnVal The value to return if the function fails\n   *\n   * @return {webdriver.promise.Promise|Q.Promise} A promise which resolves to the\n   *     function's return value\n   */\n  safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal) {\n    const resolver = done => {\n      const logError = e => {\n        if (this.resultsReported) {\n          this.printPluginResults([{\n            description: pluginObj.name + ' Runtime',\n            assertions: [{\n              passed: false,\n              errorMsg: 'Failure during ' + funName + ': ' + (e.message || e),\n              stackTrace: e.stack\n            }]\n          }]);\n        } else {\n          pluginObj.addFailure('Failure during ' + funName + ': ' + e.message || e, {\n            stackTrace: e.stack\n          });\n        }\n\n        done(failReturnVal);\n      };\n\n      try {\n        const result = pluginObj[funName].apply(pluginObj, args);\n\n        if (webdriver.promise.isPromise(result)) {\n          result.then(done, logError);\n        } else {\n          done(result);\n        }\n      } catch (e) {\n        logError(e);\n      }\n    };\n\n    if (promiseType == PromiseType.Q) {\n      return q.Promise(resolver);\n    } else if (ptor_1.protractor.browser.controlFlowIsEnabled()) {\n      return new webdriver.promise.Promise(resolver);\n    } else {\n      return new Promise(resolver);\n    }\n  }\n\n  pluginFunFactory(funName, promiseType, failReturnVal) {\n    return (...args) => {\n      const promises = this.pluginObjs.filter(pluginObj => typeof pluginObj[funName] === 'function').map(pluginObj => this.safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal));\n      return promiseType == PromiseType.Q ? q.all(promises) : webdriver.promise.all(promises);\n    };\n  }\n\n}\n\nexports.Plugins = Plugins;","map":{"version":3,"names":["Object","defineProperty","exports","value","q","require","webdriver","configParser_1","logger_1","ptor_1","logger","Logger","PromiseType","Plugins","constructor","config","setup","pluginFunFactory","Q","onPrepare","teardown","postResults","postTest","onPageLoad","WEBDRIVER","onPageStable","waitForPromise","waitForCondition","pluginObjs","assertions","resultsReported","plugins","forEach","pluginConf","i","path","ConfigParser","resolveFilePatterns","configDir","Error","package","pluginObj","inline","annotatePluginObj","debug","name","push","obj","conf","addAssertion","info","passed","message","specName","assertion","errorMsg","stackTrace","addFailure","addSuccess","options","addWarning","warn","printPluginResults","specResults","green","red","normalColor","printResult","pass","specResult","map","x","reduce","y","description","error","replace","getResults","results","failedCount","filter","length","skipAngularStability","result","some","safeCallPluginFun","funName","args","promiseType","failReturnVal","resolver","done","logError","e","stack","apply","promise","isPromise","then","Promise","protractor","browser","controlFlowIsEnabled","promises","all"],"sources":["/Users/hthere215/Desktop/Study/Classes/INF4MTX 133/Project/Project 4/a4-sleeptracker-hthere21/sleeptracker/node_modules/protractor/built/plugins.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst q = require(\"q\");\nconst webdriver = require(\"selenium-webdriver\");\nconst configParser_1 = require(\"./configParser\");\nconst logger_1 = require(\"./logger\");\nconst ptor_1 = require(\"./ptor\");\nlet logger = new logger_1.Logger('plugins');\nvar PromiseType;\n(function (PromiseType) {\n    PromiseType[PromiseType[\"Q\"] = 0] = \"Q\";\n    PromiseType[PromiseType[\"WEBDRIVER\"] = 1] = \"WEBDRIVER\";\n})(PromiseType = exports.PromiseType || (exports.PromiseType = {}));\n/**\n * The plugin API for Protractor.  Note that this API is unstable. See\n * plugins/README.md for more information.\n *\n * @constructor\n * @param {Object} config parsed from the config file\n */\nclass Plugins {\n    constructor(config) {\n        /**\n         * @see docs/plugins.md#writing-plugins for information on these functions\n         */\n        this.setup = this.pluginFunFactory('setup', PromiseType.Q);\n        this.onPrepare = this.pluginFunFactory('onPrepare', PromiseType.Q);\n        this.teardown = this.pluginFunFactory('teardown', PromiseType.Q);\n        this.postResults = this.pluginFunFactory('postResults', PromiseType.Q);\n        this.postTest = this.pluginFunFactory('postTest', PromiseType.Q);\n        this.onPageLoad = this.pluginFunFactory('onPageLoad', PromiseType.WEBDRIVER);\n        this.onPageStable = this.pluginFunFactory('onPageStable', PromiseType.WEBDRIVER);\n        this.waitForPromise = this.pluginFunFactory('waitForPromise', PromiseType.WEBDRIVER);\n        this.waitForCondition = this.pluginFunFactory('waitForCondition', PromiseType.WEBDRIVER, true);\n        this.pluginObjs = [];\n        this.assertions = {};\n        this.resultsReported = false;\n        if (config.plugins) {\n            config.plugins.forEach((pluginConf, i) => {\n                let path;\n                if (pluginConf.path) {\n                    path = configParser_1.ConfigParser.resolveFilePatterns(pluginConf.path, true, config.configDir)[0];\n                    if (!path) {\n                        throw new Error('Invalid path to plugin: ' + pluginConf.path);\n                    }\n                }\n                else {\n                    path = pluginConf.package;\n                }\n                let pluginObj;\n                if (path) {\n                    pluginObj = require(path);\n                }\n                else if (pluginConf.inline) {\n                    pluginObj = pluginConf.inline;\n                }\n                else {\n                    throw new Error('Plugin configuration did not contain a valid path or ' +\n                        'inline definition.');\n                }\n                this.annotatePluginObj(pluginObj, pluginConf, i);\n                logger.debug('Plugin \"' + pluginObj.name + '\" loaded.');\n                this.pluginObjs.push(pluginObj);\n            });\n        }\n    }\n    ;\n    /**\n     * Adds properties to a plugin's object\n     *\n     * @see docs/plugins.md#provided-properties-and-functions\n     */\n    annotatePluginObj(obj, conf, i) {\n        let addAssertion = (info, passed, message) => {\n            if (this.resultsReported) {\n                throw new Error('Cannot add new tests results, since they were already ' +\n                    'reported.');\n            }\n            info = info || {};\n            const specName = info.specName || (obj.name + ' Plugin Tests');\n            const assertion = { passed: passed };\n            if (!passed) {\n                assertion.errorMsg = message;\n                if (info.stackTrace) {\n                    assertion.stackTrace = info.stackTrace;\n                }\n            }\n            this.assertions[specName] = this.assertions[specName] || [];\n            this.assertions[specName].push(assertion);\n        };\n        obj.name = obj.name || conf.name || conf.path || conf.package || ('Plugin #' + i);\n        obj.config = conf;\n        obj.addFailure = (message, info) => {\n            addAssertion(info, false, message);\n        };\n        obj.addSuccess = (options) => {\n            addAssertion(options, true);\n        };\n        obj.addWarning = (message, options) => {\n            options = options || {};\n            logger.warn('Warning ' +\n                (options.specName ? 'in ' + options.specName : 'from \"' + obj.name + '\" plugin') + ': ' +\n                message);\n        };\n    }\n    printPluginResults(specResults) {\n        const green = '\\x1b[32m';\n        const red = '\\x1b[31m';\n        const normalColor = '\\x1b[39m';\n        const printResult = (message, pass) => {\n            logger.info(pass ? green : red, '\\t', pass ? 'Pass: ' : 'Fail: ', message, normalColor);\n        };\n        for (const specResult of specResults) {\n            const passed = specResult.assertions.map(x => x.passed).reduce((x, y) => (x && y), true);\n            printResult(specResult.description, passed);\n            if (!passed) {\n                for (const assertion of specResult.assertions) {\n                    if (!assertion.passed) {\n                        logger.error('\\t\\t' + assertion.errorMsg);\n                        if (assertion.stackTrace) {\n                            logger.error('\\t\\t' + assertion.stackTrace.replace(/\\n/g, '\\n\\t\\t'));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Gets the tests results generated by any plugins\n     *\n     * @see lib/frameworks/README.md#requirements for a complete description of what\n     *     the results object must look like\n     *\n     * @return {Object} The results object\n     */\n    getResults() {\n        const results = { failedCount: 0, specResults: [] };\n        for (const specName in this.assertions) {\n            results.specResults.push({ description: specName, assertions: this.assertions[specName] });\n            results.failedCount +=\n                this.assertions[specName].filter(assertion => !assertion.passed).length;\n        }\n        this.printPluginResults(results.specResults);\n        this.resultsReported = true;\n        return results;\n    }\n    ;\n    /**\n     * Returns true if any loaded plugin has skipAngularStability enabled.\n     *\n     * @return {boolean}\n     */\n    skipAngularStability() {\n        const result = this.pluginObjs.some(pluginObj => pluginObj.skipAngularStability);\n        return result;\n    }\n    ;\n    /**\n     * Calls a function from a plugin safely.  If the plugin's function throws an\n     * exception or returns a rejected promise, that failure will be logged as a\n     * failed test result instead of crashing protractor.  If the tests results have\n     * already been reported, the failure will be logged to the console.\n     *\n     * @param {Object} pluginObj The plugin object containing the function to be run\n     * @param {string} funName The name of the function we want to run\n     * @param {*[]} args The arguments we want to invoke the function with\n     * @param {PromiseType} promiseType The type of promise (WebDriver or Q) that\n     *    should be used\n     * @param {boolean} resultsReported If the results have already been reported\n     * @param {*} failReturnVal The value to return if the function fails\n     *\n     * @return {webdriver.promise.Promise|Q.Promise} A promise which resolves to the\n     *     function's return value\n     */\n    safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal) {\n        const resolver = (done) => {\n            const logError = (e) => {\n                if (this.resultsReported) {\n                    this.printPluginResults([{\n                            description: pluginObj.name + ' Runtime',\n                            assertions: [{\n                                    passed: false,\n                                    errorMsg: 'Failure during ' + funName + ': ' + (e.message || e),\n                                    stackTrace: e.stack\n                                }]\n                        }]);\n                }\n                else {\n                    pluginObj.addFailure('Failure during ' + funName + ': ' + e.message || e, { stackTrace: e.stack });\n                }\n                done(failReturnVal);\n            };\n            try {\n                const result = pluginObj[funName].apply(pluginObj, args);\n                if (webdriver.promise.isPromise(result)) {\n                    result.then(done, logError);\n                }\n                else {\n                    done(result);\n                }\n            }\n            catch (e) {\n                logError(e);\n            }\n        };\n        if (promiseType == PromiseType.Q) {\n            return q.Promise(resolver);\n        }\n        else if (ptor_1.protractor.browser.controlFlowIsEnabled()) {\n            return new webdriver.promise.Promise(resolver);\n        }\n        else {\n            return new Promise(resolver);\n        }\n    }\n    pluginFunFactory(funName, promiseType, failReturnVal) {\n        return (...args) => {\n            const promises = this.pluginObjs.filter(pluginObj => typeof pluginObj[funName] === 'function')\n                .map(pluginObj => this.safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal));\n            return promiseType == PromiseType.Q ? q.all(promises) : webdriver.promise.all(promises);\n        };\n    }\n}\nexports.Plugins = Plugins;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}